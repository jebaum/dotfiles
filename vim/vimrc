" Initial setup {{{
colorscheme guimiromod
runtime macros/matchit.vim
set guifont=DejaVuSansMonoforPowerline\ 11
let mapleader = ','
" Vim-Plug {{{
if !filereadable($HOME . "/.vim/autoload/plug.vim")
  execute "silent !mkdir ~/.vim/autoload"
  execute "silent !curl -fLo ~/.vim/autoload/plug.vim 'https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'"
endif

if !isdirectory(expand('~/.vim/bundle'))
  let b:plug_first_time_run = 1
else
  let b:plug_first_time_run = 0
endif
let g:plug_threads = 70

call plug#begin('~/.vim/bundle')
if has('unix')
  Plug 'Shougo/vimproc.vim', {'do' : 'make'}
  Plug 'gregsexton/gitv',    {'on': 'Gitv'}
  Plug 'mhinz/vim-tmuxify'
endif

if has('python')
  Plug 'honza/vim-snippets'
  Plug 'SirVer/ultisnips'
  Plug 'Valloric/MatchTagAlways'
endif

" in directories with java projects, I want to use youcompleteme + eclim
function! InJavaDirectory()
  let JavaDirs = [$HOME . '/Dropbox/Documents/UCLA/Y4Q1/cs130/YAMLCal']
  for entry in JavaDirs | if getcwd() == entry | return 1 | endif | endfor
endfunction

" settings for completion plugins defined in `after/plugin` directory
if has('python') && (exists('g:ycm') || InJavaDirectory())
  " use YCM if we have python, are in a java directory, or g:ycm was defined at launch with --cmd
  Plug 'Valloric/YouCompleteMe'
  let g:EclimCompletionMethod = 'omnifunc'
elseif has('lua')
  Plug 'Shougo/neocomplete.vim'
else
  " Plug 'Shougo/neocomplcache.vim'
  " Plug 'JazzCore/neocomplcache-ultisnips'
  Plug 'othree/vim-autocomplpop'
  Plug 'eparreno/vim-l9'
endif

Plug 'Shougo/unite.vim'
Plug 'inside/unite-argument'
Plug 'lambdalisue/vim-gista'
Plug 'majkinetor/unite-cmdmatch'
Plug 'sgur/unite-qf'
Plug 'Shougo/unite-help'
Plug 'Shougo/unite-outline'
Plug 'Shougo/unite-session'
Plug 'tsukkee/unite-tag'
Plug 'ujihisa/unite-locate'
" Plug 'Shougo/neossh.vim' ", {'on': ['Unite', 'VimFiler']}

"Plug 'bling/vim-airline'
Plug 'bruno-/vim-husk'
Plug 'christoomey/vim-tmux-navigator'
Plug 'ciaranm/detectindent'
Plug 'dockyard/vim-easydir'
Plug 'mtth/scratch.vim',     {'on': ['Scratch', 'ScratchInsert', 'ScratchSelection']}
Plug 'gcmt/taboo.vim'
Plug 'godlygeek/tabular',    {'on': ['Tabularize', 'TabFirst']}
Plug 'idbrii/AsyncCommand',  {'on': ['AsyncPending', 'AsyncCommand', 'AsyncShell', 'AsyncGrep', 'AsyncMake', 'AsyncCscopeFindX', 'AsyncCscopeFindSymbol', 'AsyncCscopeFindCalls']}
Plug 'jamessan/vim-gnupg'
Plug 'jaxbot/github-issues.vim', {'on': ['Gissues', 'Giadd', 'Giedit']}
Plug 'jaxbot/semantic-highlight.vim', {'on': ['SemanticHighlightToggle', 'SemanticHighlight', 'SemanticHighlightRevert']}
Plug 'junegunn/fzf'
Plug 'junegunn/vim-github-dashboard', {'on': ['GHActivity', 'GHDashboard']}
Plug 'junegunn/vim-oblique'
Plug 'junegunn/vim-pseudocl'
Plug 'justinmk/vim-matchparenalways', {'for': ['c', 'cpp', 'java', 'javascript', 'lisp']}
Plug 'justinmk/vim-sneak'
Plug 'kshenoy/vim-togglelist', {'on': ['ToggleLL', 'ToggleQF']}
Plug 'luochen1990/rainbow'
Plug 'majutsushi/tagbar',    {'on': ['Tagbar', 'TagbarOpen']}
Plug 'manuel-colmenero/vim-simple-session'
Plug 'mattn/webapi-vim' " required by vim-github-comment
Plug 'mhinz/vim-signify',    {'on': ['SignifyToggle', 'SignifyToggleHighlight', '<Plug>(signify-next-hunk', '<Plug>(signify-prev-hunk)']}
Plug 'mhinz/vim-startify'
Plug 'mmozuras/vim-github-comment', {'on': 'GHComment'}
Plug 'osyo-manga/vim-anzu'
Plug 'osyo-manga/vim-over',  {'on': ['OverCommandLine', 'OverCommandLineMap', 'OverCommandLineNoremap']}
Plug 'rking/ag.vim',         {'on': ['Ag', 'AgAdd', 'AgFromSearch', 'LAg', 'LAgAdd', 'AgFile', 'AgHelp', 'LAgHelp']}
Plug 'scrooloose/nerdcommenter'
Plug 'scrooloose/syntastic'
Plug 'Shougo/vimfiler.vim',  {'on': ['VimFiler', 'VimFilerExplorer']}
Plug 'Shougo/vinarise.vim',  {'on': ['Vinarise', 'VinariseDump', 'VinariseScript2Hex']}
Plug 't9md/vim-choosewin',   {'on': ['ChooseWin', '<Plug>(choosewin)', '<Plug>(choosewin-swap)', '<Plug>(choosewin-swap-again)']}
Plug 'thinca/vim-quickrun',  {'on': 'QuickRun'}
Plug 'tmhedberg/SimpylFold', {'for': 'python'}
Plug 'tommcdo/vim-exchange', {'on': ['<Plug>(Exchange)', '<Plug>(ExchangeClear)', '<Plug>(ExchangeLine)']}
Plug 'tpope/vim-abolish',    {'on': ['Abolish', 'Subvert', 'S']}
Plug 'tpope/vim-dispatch',   {'on': ['Make', 'Copen', 'Dispatch', 'FocusDispatch', 'Start', 'Spawn']}
Plug 'tpope/vim-eunuch',     {'on': ['Unlink', 'Remove', 'Move', 'Rename', 'Chmod', 'Mkdir', 'Find', 'Locate', 'SudoEdit', 'SudoWrite', 'Wall', 'W']}
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-unimpaired'
Plug 'vim-pandoc/vim-pandoc',        {'for': 'pandoc'}
Plug 'vim-pandoc/vim-pandoc-syntax', {'for': 'pandoc'}
Plug 'vim-pandoc/vim-pandoc-after',  {'for': 'pandoc'}
Plug 'vim-scripts/SyntaxRange', {'for': ['markdown', 'pandoc']} " TODO causes problems when doing :h thing.txt
Plug 'wellle/targets.vim'
Plug '~/.vim/eclim', {'for': 'java'}


Plug 'justinmk/vim-syntax-extra' " lazy load for c, lex, yacc filetype
Plug 'junegunn/goyo.vim'
Plug 'junegunn/vim-after-object'
autocmd VimEnter * call after_object#enable('=', ':', '-', '#', ' ')
" Plug 'junkblocker/patchreview-vim'
" Plug 'codegram/vim-codereview'

" Commands for editing wiki pages to Gitit
command! -nargs=1 Wiki execute ":split $HOME/Dropbox/wikidata/" . fnameescape("<args>.page") | execute ":Gwrite"

call plug#end()
if b:plug_first_time_run == 1
  PlugInstall
endif
" }}}
" }}}
" Misc {{{
" Mail / Mutt {{{
augroup MUTT " spell check, textwidth, F1-3 for wrapping paragraphs in useful ways
  autocmd BufRead /tmp/mutt-* set tw=72  " for email with mutt
  autocmd BufRead /tmp/mutt-* set spell  " <-- vim 7 required
augroup END
" }}}
" Fix borders of fullscreen GUI {{{
if has('gui_gtk') && has('gui_running')
    let s:border = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'gui')
    exe 'silent !echo ''style "vimfix" { bg[NORMAL] = "' . escape(s:border, '#') . '" }'''.
                \' > ~/.gtkrc-2.0.mine'
    exe 'silent !echo ''widget "vim-main-window.*GtkForm" style "vimfix"'''.
                \' >> ~/.gtkrc-2.0.mine'
endif
" }}}
" Return to last edit position when opening files {{{
augroup ReturnToLast
  autocmd BufReadPost *
       \ if line("'\"") > 0 && line("'\"") <= line("$") |
       \   exe "normal! g`\"" |
       \ endif
augroup END
" }}}
" Command mode maps and abbreviations {{{
command! CD cd %:p:h
command! SearchCount %s///gn
" cnoreabbrev lva lvimgrepadd
" cnoreabbrev lvg lvimgrep
" cnoreabbrev te tabedit
" cnoreabbrev sv source ~/.vim/vimrc
" cnoreabbrev sc source ~/.vim/colors/guimiromod.vim
" cnoreabbrev va vimgrepadd
" cnoreabbrev vg vimgrep

cnoremap <C-p>  <Up>
cnoremap <C-n>  <Down>

" use one of these maps in the middle of a search to move, copy, or delete text
cnoremap $t <CR>:t''<CR>
cnoremap $T <CR>:''t.<CR>
cnoremap $m <CR>:m''<CR>
cnoremap $M <CR>:''m.<CR>
cnoremap $d <CR>:d<CR>``
" }}}
" SyntaxRange autocmds {{{
" last parameter is optional and can be any highlight group, determines delimiter colors
augroup SyntaxNotes
  " for backward compatibility
  autocmd BufEnter *.md,*.page call SyntaxRange#Include('@begin=c@',    '@end=c@',    'c',    'Comment')
  autocmd BufEnter *.md,*.page call SyntaxRange#Include('@begin=cpp@',  '@end=cpp@',  'cpp',  'Comment')
  autocmd BufEnter *.md,*.page call SyntaxRange#Include('@begin=lisp@', '@end=lisp@', 'lisp', 'Comment')
  autocmd BufEnter *.md,*.page call SyntaxRange#Include('@begin=ml@',   '@end=ml@',   'ocaml','Comment')
  autocmd BufEnter *.md,*.page call SyntaxRange#Include('@begin=text@', '@end=text@', 'text', 'Tabline')

  autocmd BufEnter *.md,*.page call SyntaxRange#Include('```c',      '```', 'c',      'Comment')
  autocmd BufEnter *.md,*.page call SyntaxRange#Include('```cpp',    '```', 'cpp',    'Comment')
  autocmd BufEnter *.md,*.page call SyntaxRange#Include('```java',   '```', 'java',   'Comment')
  autocmd BufEnter *.md,*.page call SyntaxRange#Include('```lisp',   '```', 'lisp',   'Comment')
  autocmd BufEnter *.md,*.page call SyntaxRange#Include('```ml',     '```', 'ocaml',  'Comment')
  autocmd BufEnter *.md,*.page call SyntaxRange#Include('```prolog', '```', 'prolog', 'Comment')
  autocmd BufEnter *.md,*.page call SyntaxRange#Include('```python', '```', 'python', 'Comment')
  autocmd BufEnter *.md,*.page call SyntaxRange#Include('```text',   '```', 'text',   'Tabline')
  autocmd BufEnter *.md,*.page call SyntaxRange#Include('```javascript',   '```', 'javascript',   'Comment')
augroup END
" }}}
" FileType autocmds {{{
augroup FileTypeSettings
  " autocmd BufWritePre * :call StripTrailingWhitespace()
  autocmd FileType gitcommit setlocal nocursorline nocursorcolumn
  autocmd FileType lisp setlocal foldmethod=indent foldlevel=0
  autocmd FileType make setlocal noexpandtab shiftwidth=4 tabstop=4
  autocmd FileType ocaml call MapInterpreter('ocaml', 'ocaml')
  autocmd FileType vimfiler setlocal relativenumber
  autocmd BufNewFile,BufRead  .tags set filetype=tags
  autocmd BufNewFile,BufRead *.log  set filetype=log
  autocmd BufRead,BufNewFile *.md set filetype=pandoc
  autocmd FileType markdown,pandoc nnoremap <buffer> <leader>m1 :call MarkdownMargin(1)<CR>
  autocmd FileType markdown,pandoc nnoremap <buffer> <leader>mb :call MarkdownToggle('md_linebreak', '+hard_line_breaks', 'turned on hard line breaks', 'turned off hard line breaks')<CR>
  autocmd FileType markdown,pandoc nnoremap <buffer> <leader>md :call MarkdownToggle('md_doublespace', ' -H ~/dotfiles/pandoc/doublespace.sty', 'turned on double spacing', 'turned off double spacing')<CR>
  autocmd FileType markdown,pandoc nnoremap <buffer> <leader>mm :call MarkdownToggle('md_mla', ' --template=mla_pandoc.tex', 'using MLA, double space and hard line break turned off. make sure mla_pandoc.tex is in current directory', 'not using MLA')<CR>
  autocmd FileType markdown,pandoc nnoremap <buffer> <leader>mp :call MarkdownToggle('md_presentation', ' -t beamer --slide-level=2 -V theme:Copenhagen', 'using beamer with Copenhagen theme, slide level 2', 'not using beamer')<CR>
  autocmd FileType markdown,pandoc nnoremap <buffer> <leader>ms :call MarkdownToggle('md_highlight', ' --no-highlight', 'turned on highlighting', 'turned off highlighting')<CR>
  autocmd FileType markdown,pandoc nnoremap <buffer> <leader>mr :w!<CR>:silent call MarkdownCommandRun('','removed','pdf')<CR>:echo b:md_msg<CR>
  autocmd FileType markdown,pandoc nnoremap <buffer> <leader>mv :call MarkdownCommandRun('','open', 'pdf')<CR>
  autocmd FileType markdown,pandoc nnoremap <buffer><silent> <leader>mw :w!<CR>:silent call MarkdownCommandRun('quickrun','built','html')<CR>
  autocmd FileType markdown,pandoc nnoremap <buffer><silent> gr :w!<CR>:silent call MarkdownCommandRun('quickrun','built','pdf')<CR>
  autocmd FileType tex      nnoremap <buffer> <leader>mv :call system("mupdf " . shellescape(expand('%:p:r')).'.pdf &')<CR>
  autocmd FileType tex      nnoremap <buffer><silent> gr  :w!<CR>:exe 'QuickRun latex -args "--pdf --warn all ' . shellescape(expand('%:p')) . '"'<CR>
augroup END
" }}}
" align quickfix output {{{
augroup QuickfixAlign
autocmd BufRead quickfix setl modifiable
            \| silent exe "%!perl -ple '
                \my ($file, $pos, $msg) = split qr{[|]}, $_, 3;
                \my $aligned_pos = sub {
                \  my @p = split qr{[ ]}, shift;
                \  return                                        if @p == 0;
                \  return sprintf q{\\%3s}, @p                   if @p == 1;
                \  return sprintf q{\\%3s \\%s}, @p              if @p == 2;
                \  return sprintf q{\\%3s \\%s \\%2s}, @p        if @p == 3;
                \  return sprintf q{\\%3s \\%s \\%2s \\%-8s}, @p if @p == 4;
                \  return join q{ }, @p;
                \}->($pos);
                \$_ = join q{|}, $file, $aligned_pos, $msg;
            \'"
            \| setl nomodifiable
augroup END
" }}}
" }}}
" Functions {{{
" StripTrailingWhitespace function {{{
function! StripTrailingWhitespace()
  let l = line(".")
  let c = col(".")
  %s/\s\+$//e
  call cursor(l, c)
endfunction
" }}}
" CustomMatch function {{{
function! CustomMatch(pattern)
  let search_string = "/" . a:pattern . "/"
  execute 'match MatchTarget ' . search_string
endfunction
command! -nargs=1 MatchText call CustomMatch(<f-args>)
cnoreabbrev mt MatchText
" }}}
" Qargs, Qdof, Qdol {{{
" :Qargs will populate the arglist with the files in the quickfix list
command! -nargs=0 -bar Qargs execute 'args' QuickfixFilenames()
cnoreabbrev qargs Qargs

" :Qdol applies an arbitrary command to every line found by :vimgrep (:Qdol normal @q)
command! -nargs=1 Qdol try | sil cfirst |
  \ while 1 | exec <q-args> | sil cn | endwhile |
  \ catch /^Vim\%((\a\+)\)\=:E\%(553\|42\):/ |
  \ endtry
cnoreabbrev qdol Qdol

" :Qdof applies an arbitrary command to every file found by :vimgrep (at line of first match)
command! -nargs=1 Qdof try | sil cfirst |
  \ while 1 | exec <q-args> | sil cnf | endwhile |
  \ catch /^Vim\%((\a\+)\)\=:E\%(553\|42\):/ |
  \ endtry
cnoreabbrev qdof Qdof

" implementation of Qargs
function! QuickfixFilenames()
  " Building a hash ensures we get each buffer only once
  let buffer_numbers = {}
  for quickfix_item in getqflist()
    let buffer_numbers[quickfix_item['bufnr']] = bufname(quickfix_item['bufnr'])
  endfor
  return join(map(values(buffer_numbers), 'fnameescape(v:val)'))
endfunction
" }}}
" Location list loop function {{{
function! WrapCommand(window, direction)
  if a:direction == "up"
    try
      execute a:window . 'previous'
    catch /^Vim\%((\a\+)\)\=:E553/
      execute a:window . 'last'
    endtry
  elseif a:direction == "down"
    try
      execute a:window . 'next'
    catch /^Vim\%((\a\+)\)\=:E553/
      execute a:window . 'first'
    endtry
  endif
endfunction

" nnoremap <Home> :call WrapCommand("l", "up")<CR>
" nnoremap <End>  :call WrapCommand("l", "down")<CR>
" }}}
" Visual mode increment function {{{
function! Increment()
  let a = line('.') - line("'<")
  let c = virtcol("'<")
  if a > 0
    execute 'normal! '.c.'|'.a."\<C-a>"
  endif
  normal `<
endfunction
" }}}
" Preserve, OpenQuickfix, AgOpenQF, BufGrep, CurBufGrep {{{
function! Preserve(command, ...)
  let curbuf = bufnr('%')
  let view = winsaveview()
  let search = @/

  let g:last_preserve = a:command
  execute a:command

  execute 'buffer ' . curbuf
  call winrestview(view)
  let @/ = search

  " optional command to run when done
  if a:0
    execute a:1
  endif
endfunction

function! OpenQuickfix(...)
  let curwin = winnr()
  if a:0
    execute a:1
  endif
  cwindow
  execute curwin . 'wincmd w'
endfunction
autocmd QuickFixCmdPost * call OpenQuickfix()

command! -nargs=1 -bar AgOpenQF call OpenQuickfix('Ag! ' . <f-args>)
" /dev/empty doesn't exist, error is suppressed by `silent!`. used to set title of quickfix window, since [l]vimgrepadd doesn't update that
command! -nargs=1 -bar BufGrep call Preserve('silent! vimgrep /' . <f-args> . '/gj /dev/empty | silent! noautocmd bufdo vimgrepadd /' . <f-args> . '/gj %', 'call OpenQuickfix()')
command! -nargs=1 -bar CurBufGrep execute 'vimgrep /' . <f-args> . '/gj %'
" }}}
" VisualStarSearch function and maps {{{
function! VSetSearch(cmdtype) " makes * and # work on visual mode too.
  let temp = @s
  norm! gv"sy
  let @/ = '\V' . substitute(escape(@s, a:cmdtype.'\'), '\n', '\\n', 'g')
  let @s = temp
endfunction
" }}}
" GenerateRunCommand function {{{
" an autocmd sets b:dispatch to the output of this command for certain filetypes
function! GenerateRunCommand(...)
  if a:0 == 1
    let ftype = a:1
  else
    let ftype = &filetype
  endif

  if ftype == 'c' || ftype == 'cpp'
    return shellescape(expand('%:p:r'))
  elseif ftype == 'sh'
    return 'bash ' . shellescape(expand('%'))
  elseif ftype == 'python'
    return 'python ' . shellescape(expand('%'))
  elseif ftype == 'ocaml'
    return 'ocaml ' . shellescape(expand('%'))
  elseif ftype == 'lisp'
    return 'clisp ' . shellescape(expand('%'))
  endif

endfunction
" }}}
" Run shell command, put output in split function {{{
function! s:ExecuteInShell(command, bang)
  let _ = a:bang != '' ? s:_ : a:command == '' ? '' : join(map(split(a:command), 'expand(v:val)'))
  if (_ != '')
    let s:_ = _
    let bufnr = bufnr('%')
    let winnr = bufwinnr('^' . _ . '$')
    silent! execute  winnr < 0 ? 'belowright new ' . fnameescape(_) : winnr . 'wincmd w'
    setlocal buftype=nowrite bufhidden=wipe nobuflisted noswapfile wrap number
    silent! :%d
    let message = 'Execute ' . _ . '...'
    call append(0, message)
    echo message
    silent! 2d | resize 1 | redraw
    silent! execute 'silent! %!'. _
    silent! execute 'resize ' . line('$')
    silent! execute 'syntax on'
    silent! execute 'autocmd BufUnload <buffer> execute bufwinnr(' . bufnr . ') . ''wincmd w'''
    silent! execute 'autocmd BufEnter <buffer> execute ''resize '' .  line(''$'')'
    silent! execute 'nnoremap <silent> <buffer> <CR> :call <SID>ExecuteInShell(''' . _ . ''', '''')<CR>'
    silent! execute 'nnoremap <silent> <buffer> <LocalLeader>r :call <SID>ExecuteInShell(''' . _ . ''', '''')<CR>'
    silent! execute 'nnoremap <silent> <buffer> <LocalLeader>g :execute bufwinnr(' . bufnr . ') . ''wincmd w''<CR>'
    nnoremap <silent> <buffer> <C-W>_ :execute 'resize ' . line('$')<CR>
    silent! syntax on
  endif
endfunction

command! -complete=shellcmd -nargs=* -bang Shell call s:ExecuteInShell(<q-args>, '<bang>')
" }}}
" Create maps to run buffer/visual selection through interpreter {{{
function! MapInterpreter(ftype, interpreter)
  execute 'nnoremap <leader>i :silent! bdelete /tmp/' . a:ftype . '<CR>:15split /tmp/' . a:ftype . ' \| %d \|setlocal ft=' . a:ftype . ' \| setlocal autowrite \| r!' . a:interpreter . ' < #<CR>:normal ggdd<CR>:silent w \| echo "did some ' . a:interpreter . '"<CR><C-w>p'

  execute 'vnoremap <leader>i y:silent! bdelete /tmp/' . a:ftype . '<CR>:15split /tmp/' . a:ftype . ' \| %d _ \| put \| write<CR>:normal! gg<CR>:setlocal ft=' . a:ftype . ' \| setlocal autowrite \| r!' . a:interpreter . ' < %<CR>:normal! jdGggdd<CR>:silent w \| echo "did some ' . a:interpreter . '"<CR><C-w>p'
endfunction
" }}}
" toggle laststatus {{{
function! ToggleLaststatus()
  if &laststatus == 2
    set laststatus=1
    echo 'laststatus=1'
  else
    set laststatus=2
    echo 'laststatus=2'
  endif
endfunction
nnoremap g<Space> :call ToggleLaststatus()<CR>
" }}}
" View command to capture ex command output {{{
function! ViewWrapper(command)
  redir => message
  silent! execute a:command
  redir END
  tabnew
  call append(0, a:command)
  silent! put=message
  set nomodified
endfunction
command! -nargs=1 -bar View call ViewWrapper(<f-args>)
" }}}
" Markdown functions {{{
" default values. spaces are only put at beginning of option value if needed
function! MarkdownConfigInitialize()
  let mybuf = bufname('%')
  if getbufvar(mybuf, 'md_engine', 'empty') == 'empty'       | let b:md_engine = ' --latex-engine=xelatex' | endif
  if getbufvar(mybuf, 'md_margin', 'empty') == 'empty'       | let b:md_margin = '0.5in'                   | endif
  if getbufvar(mybuf, 'md_linebreak', 'empty') == 'empty'    | let b:md_linebreak = '+hard_line_breaks'    | endif
  if getbufvar(mybuf, 'md_highlight', 'empty') == 'empty'    | let b:md_highlight = ' --no-highlight'      | endif
  if getbufvar(mybuf, 'md_presentation', 'empty') == 'empty' | let b:md_presentation = ''                  | endif
  if getbufvar(mybuf, 'md_doublespace', 'empty') == 'empty'  | let b:md_doublespace  = ''                  | endif
  if getbufvar(mybuf, 'md_mla', 'empty') == 'empty'          | let b:md_mla = ''                           | endif
endfunction

function! MarkdownMargin(margin)
  let b:md_margin    = a:margin . 'in'
  let b:md_linebreak = ''
  echo "changed margin to " . b:md_margin . ', turned off hard line breaks'
endfunction

function! MarkdownToggle(option, val, onmsg, blankmsg)
  let current_val = getbufvar(bufname("%"), a:option)
  if current_val == a:val
    call setbufvar(bufname("%"), a:option, '')
    echo a:blankmsg
  else
    call setbufvar(bufname("%"), a:option, a:val)
    if a:option == 'md_mla'
      let b:md_doublespace = ''
      let b:md_linebreak   = ''
    endif
    echo a:onmsg
  endif
endfunction

function! MarkdownArgsGenerate(action, output)
  call MarkdownConfigInitialize()
  let dir_fullpath  = expand('%:p:h')
  let dir_current   = expand('%:p:h:t')
  let base_name     = expand('%:p:t:r')
  let input_file    = expand('%:p')
  let pandoc_args   = b:md_doublespace . b:md_mla . ' -V geometry:margin=' . b:md_margin . b:md_engine . ' -f markdown' . b:md_linebreak . b:md_presentation . b:md_highlight
  let b:md_msg      = a:action.' '.base_name.'.'.a:output
  let b:output_file = shellescape(dir_fullpath.'/'.base_name.'.'.a:output)

  if dir_current == "notes"
    let b:md_msg      = a:action.' '.a:output.'/'.base_name.'.'.a:output
    let b:output_file = shellescape(dir_fullpath.'/'.a:output.'/'.base_name.'.'.a:output)
    call system('mkdir '.shellescape(dir_fullpath.'/'.a:output))    " will run mkdir when not needed, but no big deal
  endif
  return pandoc_args . ' ' . shellescape(input_file) . ' -o ' . b:output_file
endfunction

function! MarkdownCommandRun(method, action, output)
  let b:pandoc_args = MarkdownArgsGenerate(a:action, a:output)
  if a:action == 'built'

    if a:method == 'quickrun'
      execute 'QuickRun pandoc -args "' . b:pandoc_args . '"'
    elseif a:method == 'vim'
      echom system('pandoc' . b:pandoc_args)
    elseif a:method == 'dispatch'
      execute 'Dispatch! pandoc' . b:pandoc_args
    endif

    if a:output == 'pdf'
      call system('killall -HUP mupdf')
    endif

  elseif a:action == 'removed'
    call system('rm '.b:output_file)
  elseif a:action == 'open'
    call system('mupdf ' . b:output_file . '&')
  endif
endfunction
" }}}
" Red/Green Bar {{{
function! WideMsg(msg)
  let x=&ruler | let y=&showcmd
  set noruler noshowcmd
  redraw
  echo a:msg
  let &ruler=x | let &showcmd=y
endfunction

function! GreenBar(msg)
  echohl GreenBar
    call WideMsg(a:msg . repeat(" ", &columns - strwidth(a:msg) - 1))
  echohl None
endfunction

function! RedBar(msg)
  echohl RedBar
    call WideMsg(a:msg . repeat(" ", &columns - strwidth(a:msg) - 1))
  echohl None
endfunction
" }}}
" Source that accepts range {{{
function! DetectIfInVimFunction(...)
  " search upward from the current line for the command 'function' to see if we're currently in a function
  " if we find 'endfunction' command before we find 'function', we aren't in a function
  " if we find 'function' first, then search downward for the corresponding 'endfunction'
  " return list of function start and end line numbers if successful, list of -1 if not
  let startline   = line('.')
  let currentline = line('.')

  if a:0 != 0
    let iterlimit = a:1
  else
    let iterlimit = 250
  endif

  let i = 0
  while i < iterlimit

    " see if the text 'function' or 'endfunction' is on the current line
    let funmatchpos    = match(getline(currentline), "function!")
    let endfunmatchpos = match(getline(currentline), "endfunction")

    if funmatchpos != -1  " we found the text 'function'
      let funsynlist = map(synstack(currentline, funmatchpos + 1),'synIDattr(v:val,"name")')
      if index(funsynlist, 'vimFuncKey') >= 0 " function start markers are in the VimFuncKey syntax group
        " save the line number of the first line of the function, and reset the search position
        let startfunline = currentline
        let currentline  = startline
      endif
    endif

    if endfunmatchpos != -1 " we found the text 'endfunction'
      let endfunsynlist = map(synstack(currentline, endfunmatchpos + 1),'synIDattr(v:val,"name")')
      if index(endfunsynlist, 'vimCommand') >= 0 " endfunction markers are in the VimCommand syntax group
        if currentline == startline || exists('startfunline')
          " if we started out with the cursor on endfunction, or we've already found a function start
          let endfunline = currentline
        else " we found an endfunction before finding a function start, so we aren't currently in a function
          break
        endif
      endif
    endif

    let i += 1

    if exists('startfunline') && exists('endfunline')
      return [startfunline, endfunline]
    elseif exists('startfunline')
      " we found the function start, so now we want to search downward
      let currentline += 1
    else
      let currentline -= 1
    endif
  endwhile
  return [-1, -1]
endfunction

function! SourcePart(line1, line2)
   let tmp = @z
   silent exec a:line1.",".a:line2."yank z"
   let @z = substitute(@z, '\n\s*\\', '', 'g')
   @z
   let @z = tmp
endfunction

function! SourceCurrentFunction()
  let [startfunline, endfunline] = DetectIfInVimFunction()
  if startfunline != -1
    call SourcePart(startfunline, endfunline)
    echo 'sourced ' . strpart(getline(startfunline), strlen('function! '))
  else
    echo 'cursor is not in a function'
  endif
endfunction

" if some argument is given, this command calls built-in command :source with
" given arguments; otherwise calls function SourcePart() which sources
" visually selected lines of the buffer.
command! -nargs=? -bar -range Source if empty("<args>") | call SourcePart(<line1>, <line2>) | else | exec "so <args>" | endif
" }}}
" }}}
" Plugins {{{
" airline {{{
let g:airline_theme             = "tomorrow"
let g:airline_detect_modified   = 1
let g:airline_detect_paste      = 1
let g:airline_inactive_collapse = 1
let g:airline_readonly_symbol   = ''
let g:airline_left_alt_sep      = ''
let g:airline_right_alt_sep     = ''

""" FANCY SETTINGS
" let g:airline_left_sep      = ''
" let g:airline_right_sep     = ''
" let g:airline_branch_prefix = ' '
" let g:airline_section_z     = "%l/%L:C%c"

""" MINIMAL SETTINGS
let g:airline_left_sep  = ''
let g:airline_right_sep = ''
let g:airline_section_z = "%l/%L:C%v (%P)"

let g:airline#extensions#whitespace#symbol              = 'Ξ'
let g:airline#extensions#whitespace#trailing_format     = 's[%s]'
let g:airline#extensions#whitespace#mixed_indent_format = 't[%s]'
let g:airline#extensions#hunks#enabled                  = 1
let g:airline#extensions#hunks#non_zero_only            = 1

let g:airline_theme_patch_func = 'AirlineThemePatch'
function! AirlineThemePatch(palette)
  if g:airline_theme == 'tomorrow'
    for colors in values(a:palette.inactive)
      let colors[2] = 231  " text color of split statusline
      let colors[3] = 58   " background color of split statusline
    endfor
  endif
endfunction
" }}}
" choosewin {{{
let g:choosewin_overlay_enable = 1
" }}}
" detectindent {{{
let g:detectindent_preferred_expandtab  = 1
let g:detectindent_preferred_indent     = 4
let g:detectindent_max_lines_to_analyse = 1024
" }}}
" dispatch {{{
augroup DISPATCH
  autocmd FileType c,cpp,sh,python,ocaml,lisp     let b:dispatch = GenerateRunCommand()
augroup END
" }}}
" exchange {{{
" need to define default mappings in vimrc for vim-plug lazy loading to work
nmap cx <Plug>(Exchange)
xmap X <Plug>(Exchange)
nmap cxc <Plug>(ExchangeClear)
nmap cxx <Plug>(ExchangeLine)
" }}}
" fugitive {{{
command! -nargs=1 -bar Gbranch   call GitBranch(<f-args>)
function! GitBranch(name)
    execute 'silent Git checkout -b ' . a:name
    redraw!
endfunction

command! -nargs=1 -bar Gcheckout   call GitCheckout(<f-args>)
function! GitCheckout(name)
    execute 'silent Git checkout ' . a:name
    redraw!
endfunction

autocmd User fugitive  " .. to go back up to parent directory when browsing git tree
  \ if fugitive#buffer().type() =~# '^\%(tree\|blob\)$' |
  \   nnoremap <buffer> .. :edit %:h<CR> |
  \ endif

autocmd BufReadPost fugitive://* set bufhidden=delete  " stop fugitive from making tons of buffers
" }}}
" fzf {{{
let g:fzf_launcher='urxvt -e sh -c %s'
" }}}
" gista {{{
let g:gista#post_private = 1
" }}}
" github-comment {{{
let g:github_user = 'jebaum'
" }}}
" github-dashboard {{{
let g:github_dashboard = {'username': 'jebaum'}
" }}}
" gitv {{{
let g:Gitv_OpenHorizontal = 1
let g:Gitv_WipeAllOnClose = 1
" }}}
" match tag {{{
let g:mta_filetypes = {
    \ 'html' : 1,
    \ 'xhtml' : 1,
    \ 'xml' : 1,
    \ 'jinja' : 1,
    \ 'php' : 1,
    \}
" }}}
" matchparenalways {{{
let g:blockify_pairs = { 'lisp': [ '(', ')' ] }
" }}}
" nerdcommenter {{{
let NERDSpaceDelims     = 1
let NERDCompactSexyComs = 0
" }}}
" netrw {{{
let g:netrw_bufsettings = 'noma nomod nu nobl nowrap ro'
" }}}
" oblique {{{
let g:oblique#incsearch_highlight_all = 1
let g:oblique#very_magic = 1
" TODO: the current match that gets special highlighting can't be cleared by nohlsearch. oblique bug or lack of feature?
let g:oblique#clear_highlight = 1
map n <Plug>(Oblique-n)<Plug>(anzu-update-search-status-with-echo)zv
map N <Plug>(Oblique-N)<Plug>(anzu-update-search-status-with-echo)zv

nnoremap <silent><expr> <CR> ':set hls! ' . (&hls == 1 ? 'nocuc nocul' : 'cuc cul') . '<CR>'
nnoremap <silent><C-c> :set nocuc nocul<CR>
augroup FancyCR
  autocmd CmdwinEnter * nnoremap <buffer> <CR> <CR>
augroup END
" }}}
" pandoc {{{
augroup PandocMaps
  autocmd filetype pandoc nnoremap <buffer><silent><expr> gc ":set cole=" . (&cole != 0 ? "0" : "2") . "<CR>"
augroup END
" let g:pandoc#syntax#codeblocks#embeds#langs = ["ruby", "c"]  " achieve same affect as SyntaxRange
let g:pandoc#folding#level = 1
let g:pandoc#formatting#textwidth = 80
let g:pandoc#folding#fdc = 0 " foldcolumn width
let g:pandoc#modules#disabled = ["folding"]
let g:pandoc#after#modules#enabled = ["ultisnips", "unite"]
" }}}
" quickrun {{{
let g:quickrun_config         = {}  " initialize dictionary
let g:quickrun_config._       = {'runner':'vimproc', 'runner/vimproc/updatetime':'250','hook/getpid/enable':'1'} " _ is fallback default value
let g:quickrun_config.generic = {'exec':'%c %a'}    " any arbitrary -command and -args, e.g. `QuickRun generic -command ls -args '-al ~'`
let g:quickrun_config.make    = {'exec':'make %a','runner':'vimproc','outputter':'quickfix'}
let g:quickrun_config.pandoc  = {'exec':'pandoc %a','runner':'vimproc','outputter':'quickfix','hook/markdown/enable':'1'}
let g:quickrun_config.python  = {'cmdopt':'-u','runner':'vimproc'}      " prevent python from buffering output
let g:quickrun_config.latex   = {'exec':'rubber %a','runner':'vimproc','outputter':'quickfix','hook/markdown/enable':'1'}

function! QuickRunSplit()
    " figure out what to prepend to :split command for buffer output based on current window size
    return winwidth(0) * 2 < winheight(0) * 5 ? "15" : "vertical 45"
endfunction

function! QuickRunTimeToggle()
  if !has_key(g:quickrun_config['_'], 'hook/time/enable')
    let g:quickrun_config['_']['hook/time/enable'] = '0'
  endif
  if g:quickrun_config['_']['hook/time/enable'] == '0'
    let g:quickrun_config['_']['hook/time/enable'] = '1'
    echo 'enabled time hook'
  else
    let g:quickrun_config['_']['hook/time/enable'] = '0'
    echo 'disabled time hook'
  endif
endfunction
" }}}
" rainbow {{{
" alternative - https://github.com/junegunn/rainbow_parentheses.vim
let g:rainbow_active = 1
let g:rainbow_conf = {
\   'guifgs': ['#5FFF00', '#FF5F00', '#FFFF00', '#FF00FF', '#FFFFFF', '#FF0000'],
\   'ctermfgs': ['82', '202', '226', '201', '231', '196'],
\   'operators': '_,_',
\   'parentheses': [['(',')'], ['\[','\]'], ['{','}']],
\   'separately': {
\       '*': {},
\       'lisp': {
\           'guifgs': ['#5FFF00', '#FF5F00', '#FFFFFF', '#FF00FF', '#FFFF00', '#FF0000'],
\           'ctermfgs': ['82', '202', '231', '201', '226', '196'],
\       },
\       'css': 0,
\       'stylus': 0,
\   }
\}
" }}}
" scratch {{{
let g:scratch_filetype = 'vim'
" }}}
" semantic-highlight {{{
" TODO: make these suck less
let g:semanticTermColors = [28,1,2,3,4,5,6,7,25,9,10,34,12,13,14,15,16,125,124,19]
let g:semanticGUIColors = [ '#72d572', '#c5e1a5', '#e6ee9c', '#fff59d', '#ffe082', '#ffcc80', '#ffab91', '#bcaaa4', '#b0bec5', '#ffa726', '#ff8a65', '#f9bdbb', '#f9bdbb', '#f8bbd0', '#e1bee7', '#d1c4e9', '#ffe0b2', '#c5cae9', '#d0d9ff', '#b3e5fc', '#b2ebf2', '#b2dfdb', '#a3e9a4', '#dcedc8' , '#f0f4c3', '#ffb74d' ]
" }}}
" sessions {{{
" settings for both vim-simple-session and unite-session
call system('mkdir -p ~/.vim/session')
let g:session_dir = "~/.vim/session"
let g:unite_source_session_path = g:session_dir
" }}}
" signify {{{
let g:signify_disable_by_default = 0            " disable run by default
let g:signify_vcs_list           = [ 'git' ]    " I only use git for now
let g:signify_mapping_next_hunk  = '<leader>gj' " easier to use [c and ]c
let g:signify_mapping_prev_hunk  = '<leader>gk'
let g:signify_sign_change        = '~'
nmap <leader>gh :SignifyToggleHighlight \| SignifyToggle \| SignifyToggle<CR>
nmap <leader>gt :SignifyToggle<CR>
nmap <leader>gk <Plug>(signify-prev-hunk)
nmap <leader>gj <Plug>(signify-next-hunk)
nmap ]c         <Plug>(signify-next-hunk)
nmap [c         <Plug>(signify-prev-hunk)
" }}}
" sneak  {{{
let g:sneak#use_ic_scs = 1
let g:sneak#s_next = 0
nmap f <Plug>Sneak_f
nmap F <Plug>Sneak_F
xmap f <Plug>Sneak_f
xmap F <Plug>Sneak_F
omap f <Plug>Sneak_f
omap F <Plug>Sneak_F
nmap t <Plug>Sneak_t
nmap T <Plug>Sneak_T
xmap t <Plug>Sneak_t
xmap T <Plug>Sneak_T
omap t <Plug>Sneak_t
omap T <Plug>Sneak_T

nmap ; <Plug>SneakNext
omap ; <Plug>SneakNext
xmap ; <Plug>VSneakNext
nmap <Esc>; <Plug>SneakPrevious
omap <Esc>; <Plug>SneakPrevious
xmap <Esc>; <Plug>SneakPrevious
" }}}
" startify {{{
let g:startify_list_order        = ['bookmarks', 'dir', 'files', 'sessions']
let g:startify_bookmarks         = [ '~/dotfiles/vim/vimrc', '~/dotfiles/aliases', '~/Dropbox/todo/TODO.txt' ]
let g:startify_files_number      = 7
let g:startify_session_detection = 1 " show session when Session.vim is found in current directory
let g:startify_session_autoload  = 0 " opening directories with a Session.vim will have it auto load
let g:startify_change_to_dir     = 1 " when opening file or bookmark, change to its directory
let g:startify_custom_indices    = ['a','f','h','j','k','l','w','r','u','o','p','z','x','n','m']
if has('nvim')
  let g:startify_custom_header     = [
    \ '    /\\\\\     /\\\  /\\\        /\\\  /\\\\\\\\\\\  /\\\\            /\\\\       ',
    \ '    \/\\\\\\   \/\\\ \/\\\       \/\\\ \/////\\\///  \/\\\\\\        /\\\\\\      ',
    \ '     \/\\\/\\\  \/\\\ \//\\\      /\\\      \/\\\     \/\\\//\\\    /\\\//\\\     ',
    \ '      \/\\\//\\\ \/\\\  \//\\\    /\\\       \/\\\     \/\\\\///\\\/\\\/ \/\\\    ',
    \ '       \/\\\\//\\\\/\\\   \//\\\  /\\\        \/\\\     \/\\\  \///\\\/   \/\\\   ',
    \ '        \/\\\ \//\\\/\\\    \//\\\/\\\         \/\\\     \/\\\    \///     \/\\\  ',
    \ '         \/\\\  \//\\\\\\     \//\\\\\          \/\\\     \/\\\             \/\\\ ',
    \ '          \/\\\   \//\\\\\      \//\\\        /\\\\\\\\\\\ \/\\\             \/\\\',
    \ '           \///     \/////        \///        \///////////  \///              \///',
    \ '',
    \ '',
    \ ]
else
  let g:startify_custom_header     = [
    \ '    /\\\        /\\\   /\\\\\\\\\\\   /\\\\            /\\\\  ',
    \ '    \/\\\       \/\\\  \/////\\\///   \/\\\\\\        /\\\\\\  ',
    \ '     \//\\\      /\\\       \/\\\      \/\\\//\\\    /\\\//\\\  ',
    \ '       \//\\\    /\\\        \/\\\      \/\\\\///\\\/\\\/ \/\\\  ',
    \ '         \//\\\  /\\\         \/\\\      \/\\\  \///\\\/   \/\\\  ',
    \ '           \//\\\/\\\          \/\\\      \/\\\    \///     \/\\\  ',
    \ '             \//\\\\\           \/\\\      \/\\\             \/\\\  ',
    \ '               \//\\\         /\\\\\\\\\\\  \/\\\             \/\\\  ',
    \ '                 \///         \///////////   \///              \///   ',
    \ '',
    \ '',
    \ ]
endif
" }}}
" syntastic {{{
if executable('clang')
  let g:syntastic_c_compiler               = 'clang'
  let g:syntastic_cpp_compiler             = 'clang++'
endif
let g:syntastic_c_compiler_options       = ' -Wall -Wextra'
let g:syntastic_cpp_compiler_options     = ' -Wall -Wextra'

function! SyntasticOpenMP()
  let g:syntastic_c_compiler         = 'gcc'
  let g:syntastic_c_compiler_options = ' -I/usr/lib/gcc/x86_64-unknown-linux-gnu/4.8.2/include -fopenmp -Wall -Wextra'
endfunction

augroup OPENMP
  autocmd BufEnter /home/james/Dropbox/Documents/UCLA/Y3Q2/CS133/* call SyntasticOpenMP()
augroup END

let g:syntastic_java_javac_config_file_enabled = 1
" for allowing syntastic to find symbols in java classpath, put this in .syntastic_javac_config. must be in cwd
" let g:syntastic_java_javac_custom_classpath_command = "brazil-path testlib.classpath | gawk 'BEGIN {RS=\":\"} {print $1;}' | tr '\n' ':'"

let g:syntastic_check_on_open            = 1
let g:syntastic_check_on_wq              = 0
let g:syntastic_aggregate_errors         = 1 " display all errors
let g:syntastic_always_populate_loc_list = 1 " always put detecter errors in location list
let g:syntastic_error_symbol             = '✗✗'
let g:syntastic_warning_symbol           = '⚠⚠'
let g:syntastic_stl_format               = '[%E{E:%fe-%e}%B{|}%W{W:%fw-%w}]'
let g:syntastic_ignore_files = [
    \ '/home/james/Dropbox/Documents/UCLA/Y3Q1/CS118/Homework',
    \ '\m\.tex']
" }}}
" taboo {{{
" let g:taboo_tab_format = "%N %1a%m "
let g:taboo_tab_format = "%N %f%m "
" }}}
" tagbar {{{
let g:tagbar_left             = 1   " default is to open on right
let g:tagbar_width            = 50  " default is 40
let g:tagbar_indent           = 1   " default is 2
let g:tagbar_show_linenumbers = 2   " relative line numbers
let g_tagbar_autoshowtag      = 1   " auto unfold any parents so highlighted tag is shown
let g:tagbar_sort             = 0   " sort tags by position in source file, not alphabetically
" }}}
" tmuxify {{{
let g:tmuxify_custom_command = 'tmux split-window -dp 25'
let g:tmuxify_map_prefix = ''
let g:tmuxify_run = {}

" TODO: replace this by using the g:tmuxify_run variable above? example in the tmuxify readme
function! SetTmuxifyRun()
  if &filetype != ''
    execute 'let g:tmuxify_run.' . &filetype . '="' . GenerateRunCommand() . '"'
  endif
endfunction

" augroup TMUXIFY
  " autocmd BufEnter * call SetTmuxifyRun()
" augroup END
" }}}
" ultisnips {{{
let g:UltiSnipsExpandTrigger       = "<C-l>"
let g:UltiSnipsJumpForwardTrigger  = "<C-l>"
let g:UltiSnipsJumpBackwardTrigger = "<C-h>"
let g:UltiSnipsListSnippets        = "<C-f>"
let g:snips_author                 = 'James Baumgarten'
" }}}
" unite {{{
" Unite Menus {{{
let g:unite_source_menu_menus = {}
" menu descriptions and maps {{{
let g:unite_source_menu_menus.git = {'description': '        fugitive and other git commands                 <Space>mg'}
let g:unite_source_menu_menus.leader = {'description': '     <leader> mappings for common commands           <Space>m,'}
let g:unite_source_menu_menus.navigation = {'description': ' navigate by buffers, tabs & windows             <Space>mN'}
let g:unite_source_menu_menus.neobundle = {'description': '  plugins administration with neobundle           <Space>mn'}
let g:unite_source_menu_menus.spaceleader = {'description': '<Space> mappings for unite commands + misc      <Space>m<Space>'}
" }}}
" git menu {{{
let g:unite_source_menu_menus.git.command_candidates = [
\['▷ gitv commit browser            N/A     (gitv)              ', 'Gitv'],
\['▷ gitv file browser              N/A     (gitv)              ', 'Gitv!'],
\['▷ git add                        ,ga     (fugitive)          ', 'Git add %:p'],
\['▷ git checkout -b                ,gb     (fugitive)          ', 'exe "silent Git checkout -b " input("Branch Name: ") | redraw!'],
\['▷ git blame                      ,gB     (fugitive)          ', 'Gblame'],
\['▷ git commit --verbose           ,gc     (fugitive)          ', 'Gcommit --verbose'],
\['▷ git diff                       ,gd     (fugitive)          ', 'Gdiff'],
\['▷ git edit                       ,ge     (fugitive)          ', 'Gedit'],
\['▷ git grep -i                    ,gg     (fugitive)          ', 'exe "silent Ggrep -i ".input("Pattern: ") | copen'],
\['▷ git log - all commits          ,gla    (fugitive)          ', 'exe "silent Glog -- | redraw! | copen"'],
\['▷ git log - all commits for file ,glf    (fugitive)          ', 'exe "silent Glog -- % | redraw! | copen"'],
\['▷ git log - file versions        ,gli    (fugitive)          ', 'exe "silent Glog | redraw! | copen"'],
\['▷ git mv                         ,gm     (fugitive)          ', 'exe "Gmove " input("new filename: ")'],
\['▷ git push                       ,gp     (fugitive, dispatch)', 'Dispatch! git push'],
\['▷ git pull                       ,gP     (fugitive, dispatch)', 'Dispatch! git pull'],
\['▷ git checkout                   ,gr     (fugitive)          ', 'Gread'],
\['▷ git status                     ,gs     (fugitive)          ', 'Gstatus'],
\['▷ git add/stage                  ,gw     (fugitive)          ', 'Gwrite'],
\['▷ git command                    N/A     (fugitive)          ', 'exe "Git! " input("git command: ")'],
\['▷ git grep - messages            N/A     (fugitive)          ', 'exe "silent Glog --grep=".input("Pattern: ") | redraw!'],
\['▷ git grep - text                N/A     (fugitive)          ', 'exe "silent Glog -S".input("Pattern: ") | redraw!'],
\['▷ git rm                         N/A     (fugitive)          ', 'Gremove'],
\['▷ git browse                     N/A     (fugitive)          ', 'Gbrowse'],
\['▷ git init                       N/A     (git)               ', 'Unite output:echo\ system("git\ init")'],
\]
" }}}
" leader menu {{{
let g:unite_source_menu_menus.leader.command_candidates = [
\['▷ Targets.vim opfunc append               <leader>a',          'echo "run it yourself"'],
\['▷ Dispatch!                               <leader>d',          'Dispatch!'],
\['▷ Dispatch                                <leader><leader>d',  'Dispatch'],
\['▷ toggle copen                            <leader>e',          'lclose | let g:ToggleList.cmd.copen="copen" | ToggleQF'],
\['▷ toggle Copen (dispatch)                 <leader>E',          'lclose | let g:ToggleList.cmd.copen="Copen" | ToggleQF'],
\['▷ toggle foldmethod                       <leader>F',          'set foldmethod=syntax | set foldmethod=manual'],
\['▷ Targets.vim opfunc insert               <leader>i',          'echo "run it yourself"'],
\['▷ toggle lopen                            <leader>l',          'cclose | ToggleLL'],
\['▷ Make! -j4 all                           <leader>ma',         'Make! -j4 all'],
\['▷ Make -j4 all                            <leader><leader>ma', 'Make  -j4 all'],
\['▷ Make! clean                             <leader>mc',         'Make! clean'],
\['▷ Make clean                              <leader><leader>mc', 'Make  clean'],
\['▷ Make! -j4 <current file>                <leader>mf',         'Make! -j4 ' . expand("%:r")],
\['▷ Make -j4 <current file>                 <leader><leader>mf', 'Make  -j4 ' . expand("%:r")],
\['▷ Make! -j4                               <leader>mm',         'Make! -j4'],
\['▷ Make -j4                                <leader><leader>mm', 'Make  -j4'],
\['▷ "0p (paste from yank register)          <leader>p',          '"0p'],
\['▷ "0P (Paste from yank register)          <leader>P',          '"0P'],
\['▷ SDelete                                 <leader>sd',         'SDelete'],
\['▷ Session (load or new)                   <leader>sl',         'echo "run it yourself"'],
\['▷ find TODOs in current buffer            <leader>tt',         'silent! vimgrep /\CTODO/gj %'],
\['▷ find TODOs in all open buffers          <leader>to',         'silent! vimgrep /\CTODO/gj /dev/empty | BufGrep \CTODO'],
\['▷ find TODOs recursively                  <leader>tr',         'AgOpenQF TODO'],
\['▷ search in current buffer (CurBufGrep)   <leader>ss',         'echo CurBufGrep'],
\['▷ search in all open buffers (BufGrep)    <leader>so',         'echo BufGrep'],
\['▷ search recursively (AgOpenQF)           <leader>sr',         'echo AgOpenQF'],
\['▷ add underline to current line           <leader>u',          'yyp^v$r'],
\['▷ yank and put cursor at end              <leader>y',          'y`]'],
\['▷ show highlight groups                   <leader>zh',         'echo "run it yourself"'],
\['▷ syntax sync fromstart                   <leader>zs',         'syntax sync fromstart'],
\['▷ tabedit $MYVIMRC                        <leader>zv',         'tabedit $MYVIMRC'],
\['▷ redraw!                                 <leader><leader>a',  'redraw!'],
\]
" }}}
" navigation menu: buffers, tabs & windows {{{
let g:unite_source_menu_menus.navigation.command_candidates = [
    \['▷ buffers                                                      <Space>b', 'Unite buffer'],
    \['▷ tabs                                                         <Space>d', 'Unite tab'],
    \['▷ windows                                                      <Space>w', 'Unite window'],
    \['▷ location list                                                N/A',      'Unite locationlist'],
    \['▷ unite quickfix                                               <Space>q', 'Unite qf'],
    \['▷ new vertical window                                          <C-w>v', 'vsplit | redraw!'],
    \['▷ new horizontal window                                        <C-w>s', 'split | redraw!'],
    \['▷ close current window                                         <leader>q', 'close'],
    \['▷ toggle quickfix window                                       <leader>e', 'ToggleQF'],
    \['▷ toggle location list window                                  <leader>l', 'ToggleLL'],
    \['▷ delete buffer                                                N/A', 'bd'],
    \]
" }}}
" neobundle menu {{{
let g:unite_source_menu_menus.neobundle.command_candidates = [
\['▷ neobundle',                'Unite neobundle'],
\['▷ neobundle log',            'Unite neobundle/log'],
\['▷ neobundle lazy',           'Unite neobundle/lazy'],
\['▷ neobundle update',         'Unite -no-start-insert neobundle/update'],
\['▷ neobundle search',         'Unite neobundle/search'],
\['▷ neobundle install',        'Unite neobundle/install'],
\['▷ neobundle check',          'Unite -no-empty output:NeoBundleCheck'],
\['▷ neobundle docs',           'Unite output:NeoBundleDocs'],
\['▷ neobundle clean',          'NeoBundleClean'],
\['▷ neobundle rollback',       'exe "NeoBundleRollback" input("plugin: ")'],
\['▷ neobundle list',           'Unite output:NeoBundleList'],
\['▷ neobundle direct edit',    'NeoBundleExtraEdit'],
\]
" }}}
" spaceleader menu {{{
let g:unite_source_menu_menus.spaceleader.command_candidates = [
\['▷ Unite argument                                                   <Space>a',       'Unite          -buffer-name=arglist    argument'],
\['▷ Unite buffer                                                     <Space>b',       'Unite          -buffer-name=buffers    buffer'],
\['▷ Unite tab:no-current                                             <Space>d',       'Unite          -buffer-name=tabs       tab:no-current'],
\['▷ Unite file                                                       <Space>f',       'Unite          -buffer-name=files      file'],
\['▷ Unite grep:. (uses ag)                                           <Space>g',       'Unite          -buffer-name=ag         grep:.'],
\['▷ Unite gist                                                       <Space>G',       'Unite          -buffer-name=gist       gist'],
\['▷ Unite help                                                       <Space>h',       'Unite          -buffer-name=help       help'],
\['▷ Unite find:. pattern                                             <Space>j',       'echo "run it yourself"'],
\['▷ Unite find:. exact match                                         <Space>J',       'echo "run it yourself"'],
\['▷ Unite process (action sigkill)                                   <Space>k',       'Unite -default-action=sigkill -buffer-name=killproc process'],
\['▷ Unite locate                                                     <Space>l',       'UniteWithInput -buffer-name=locate     locate'],
\['▷ Unite launcher                                                   <Space>L',       'Unite          -buffer-name=launcher   launcher'],
\['▷ Unite line                                                       <Space>ol',      'Unite          -buffer-name=lines      line'],
\['▷ Unite outline                                                    <Space>oo',      'Unite          -buffer-name=outline    outline'],
\['▷ Unite neobundle/log                                              <Space>pl',      'Unite          -no-start-insert        neobundle/log'],
\['▷ Unite neobundle/update                                           <Space>pu',      'Unite          -no-start-insert        neobundle/update'],
\['▷ Unite quickfix                                                   <Space>q',       'Unite          -buffer-name=quickfix   qf'],
\['▷ Unite file_rec/async                                             <Space>r',       'Unite          -buffer-name=file_rec   file_rec/async'],
\['▷ Unite session                                                    <Space>sl',      'Unite          -buffer-name=sessions   session'],
\['▷ Unite session/new                                                <Space>sn',      'Unite          -buffer-name=new_session session/new'],
\['▷ Unite tag                                                        <Space>t',       'Unite          -buffer-name=tags       taga<BS>'],
\['▷ Unite function (vimscript)                                       <Space>vf',      'Unite          -buffer-name=functions  function'],
\['▷ Unite mapping                                                    <Space>vm',      'Unite          -buffer-name=mappings   mapping'],
\['▷ Unite runtimepath                                                <Space>vr',      'Unite          -buffer-name=runtimepath runtimepath'],
\['▷ Unite window:no-current                                          <Space>w',       'Unite          -buffer-name=window     window:no-current'],
\['▷ Unite source                                                     <Space><Space>', 'Unite          -buffer-name=sources    source'],
\['▷ Unite output                                                     <Space><CR>',    'Unite          -buffer-name=output     output'],
\['▷ Unite cmdmatch                                                   <Space>:',       'Unite          -buffer-name=cmdmatch   cmdmatch'],
\]
" }}}
" }}}
" Unite Settings {{{
" defaults
call unite#custom#profile('default', 'context', {
\ 'start_insert': 1,
\ 'prompt_direction' : 'top'
\ })
call unite#custom#profile('default', 'context.ignorecase', 1)
call unite#custom#profile('default', 'context.smartcase', 1)
call unite#filters#matcher_default#use(['matcher_fuzzy'])
" call unite#filters#sorter_default#use(['sorter_selecta'])
call unite#filters#sorter_default#use(['sorter_rank'])
" unite-outline settings
call unite#set_profile('outline', 'context.smartcase',  1)
let g:unite_source_outline_filetype_options = {
    \ '*': {
    \   'auto_update': 1,
    \   'auto_update_event': 'write',
    \   'ignore_types': ['comment'],
    \ },
    \}

" TODO these need to be updated with new unite style. see help for details
let g:unite_cursor_line_highlight           = "UniteSel"
let g:unite_source_file_mru_long_limit      = 3000
let g:unite_source_directory_mru_long_limit = 3000
let g:unite_enable_start_insert             = 1
let g:unite_winheight                       = 20
let g:unite_split_rule                      = 'botright'
let g:unite_prompt                          = '» '
let g:unite_update_time                     = 500   " in milliseconds
let g:unite_source_rec_async_command        = 'ag --follow --nocolor --nogroup --hidden -g ""'
let g:unite_source_history_yank_enable      = 1
let g:unite_enable_ignore_case              = 1
let g:unite_enable_smart_case               = 1

" use ag or ack instead of grep if possible
if executable('ag')
  let g:unite_source_grep_command = 'ag'
  let g:unite_source_grep_default_opts =
  \ '--line-numbers --nocolor --nogroup --hidden --ignore ' .
  \  '''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.bzr'''
  let g:unite_source_grep_recursive_opt = ''
elseif executable('ack-grep')
  let g:unite_source_grep_command = 'ack-grep'
  let g:unite_source_grep_default_opts = '--no-heading --no-color -a -H'
  let g:unite_source_grep_recursive_opt = ''
endif

" unite buffer maps
augroup unite
  autocmd FileType unite call s:unite_my_settings()
augroup END
function! s:unite_my_settings()
  nmap <buffer> <ESC>   <Plug>(unite_exit)
  nmap <buffer> <C-c>   <Plug>(unite_all_exit)
  imap <buffer> <C-c>   <Plug>(unite_insert_leave)
  imap <buffer> <C-d>   <Plug>(unite_exit)
  imap <buffer> <C-f>   <Plug>(unite_choose_action)

  imap <buffer> <Tab>   <Plug>(unite_toggle_mark_current_candidate)
  imap <buffer> <S-Tab> <Plug>(unite_toggle_mark_current_candidate_up)
  nmap <buffer> <Tab>   <Plug>(unite_toggle_mark_current_candidate)
  nmap <buffer> <S-Tab> <Plug>(unite_toggle_mark_current_candidate_up)

  imap <buffer> <C-w>   <Plug>(unite_delete_backward_path)
  nmap <buffer> '       <Plug>(unite_quick_match_default_action)
  imap <buffer> '       <Plug>(unite_quick_match_default_action)
  nmap <buffer> x       <Plug>(unite_quick_match_choose_action)
  imap <buffer><expr> x unite#smart_map('x', "\<Plug>(unite_quick_match_choose_action)")
  nmap <buffer> <C-z>   <Plug>(unite_toggle_transpose_window)
  imap <buffer> <C-z>   <Plug>(unite_toggle_transpose_window)

  imap <silent><buffer><expr> <C-s>     unite#do_action('above')
  imap <silent><buffer><expr> <C-j>     unite#do_action('below')
  imap <silent><buffer><expr> <C-x>     unite#do_action('left')
  imap <silent><buffer><expr> <C-v>     unite#do_action('right')
  imap <silent><buffer><expr> <C-t>     unite#do_action('tabopen')
  imap <silent><buffer><expr> <C-y>     unite#do_action('tabdrop')

  nmap <silent><buffer><expr> <C-s>     unite#do_action('above')
  nmap <silent><buffer><expr> <C-j>     unite#do_action('below')
  nmap <silent><buffer><expr> <C-x>     unite#do_action('left')
  nmap <silent><buffer><expr> <C-v>     unite#do_action('right')
  nmap <silent><buffer><expr> <C-t>     unite#do_action('tabopen')
  nmap <silent><buffer><expr> <C-y>     unite#do_action('tabdrop')
  execute 'imap <buffer> ' . g:ctrl_space . ' <Plug>(unite_toggle_mark_current_candidate)'

  nmap <buffer> <C-n> <Plug>(unite_loop_cursor_down)
  nmap <buffer> <C-p> <Plug>(unite_loop_cursor_up)
  nmap <buffer> l     <Plug>(unite_do_default_action)

  nnoremap <silent><buffer><expr> l unite#smart_map('l', unite#do_action('default'))
  let unite = unite#get_current_unite()
  if unite.buffer_name =~# '^search'
    nnoremap <silent><buffer><expr> r     unite#do_action('replace')
  else
    nnoremap <silent><buffer><expr> r     unite#do_action('rename')
  endif
  nnoremap <silent><buffer><expr> cd     unite#do_action('lcd')
  nnoremap <buffer><expr> S      unite#mappings#set_current_filters(
          \ empty(unite#mappings#get_current_filters()) ?
          \ ['sorter_reverse'] : [])
endfunction
" }}}
" }}}
" vimfiler {{{
let g:vimfiler_as_default_explorer  = 1
let g:vimfiler_safe_mode_by_default = 0
let g:vimfiler_ignore_pattern       = '\.o\|^\.'  " ignore object files and dotfiles
let g:vimfiler_explorer_columns     = ""
augroup vimfiler
  autocmd FileType vimfiler call s:vimfiler_my_settings()
augroup END

function! s:vimfiler_my_settings()
  silent! execute 'nunmap <buffer> <CR>'
  nmap <buffer> <CR>    <Plug>(vimfiler_choose_action)
  nmap <buffer> <Tab>   <Plug>(vimfiler_toggle_mark_current_line)
  nmap <buffer> <S-Tab> <Plug>(vimfiler_toggle_mark_current_line_up)
  nmap <buffer> l       <Plug>(vimfiler_expand_tree)
  nmap <buffer> gl      <Plug>(vimfiler_smart_l)
  nmap <buffer> cc      <Plug>(vimfiler_copy_file)
  nmap <buffer> dd      <Plug>(vimfiler_delete_file)
  nmap <silent><buffer><expr> v vimfiler#do_action('vsplit')
  nmap <silent><buffer><expr> s vimfiler#do_action('split')
  nmap <silent><buffer><expr> p vimfiler#do_action('tabdrop')
  nmap <silent><buffer><expr> o vimfiler#do_action('above')
  nmap <silent><buffer><expr> b vimfiler#do_action('below')
  nmap <silent><buffer><expr> x vimfiler#do_action('ex')
  nmap <silent><buffer><expr> f vimfiler#do_action('grep')
  nmap <silent><buffer><expr> t vimfiler#do_action('tabopen')
  nmap <silent><buffer><expr> u vimfiler#do_action('rec/async')
  nnoremap <buffer> <C-b> <C-^>zvzz
endfunction
" }}}
" }}}
" General {{{
" Set options {{{
set number                     " show line numbers
set relativenumber             " use relative line numbers
set exrc                       " allow directory specific .vimrc files
set secure                     " prevent directory specific .vimrcs from doing malicious things
set ttyfast                    " redraw screen faster
set lazyredraw                 " don't redraw the screen w ile executing macros
set restorescreen=on           " restore screen contents on exit
set clipboard=unnamedplus      " by default, use system clipboard for yanks ('+' register)
set titlestring=%t\            " file name
set title titlelen=150         " max length of title string
set backspace=indent,eol,start " allow backspace in insert mode
set esckeys                    " make numpad work
set autoread                   " reload files changed outside of vim
set splitbelow                 " splits open below
set splitright                 " vsplits open on right
set hidden                     " allows navigating away from buffers with unsaved changes
set fillchars=""               " no dashes in folds or vertical bars in vsplits
set noruler                    " don't show the ruler
set laststatus=2               " always display the statusline
set history=1000               " length of command history
set showmode                   " show what mode we're in on the bottom line
set showcmd                    " show current command or visual selection info in bottom line
set cmdwinheight=10            " height of command line window
set showmatch                  " flash to matching paren when typing
set matchtime=3                " tenths of a second to flash to matching paren
set incsearch                  " find as you type
set hlsearch                   " hilight search terms
set magic                      " change how backslashes are handled in searches
set ignorecase                 " case insensitive search by default
set fileignorecase             " ignore case in commands like :buffer
set smartcase                  " case sensitive search if search contains uppercase letter
set nostartofline              " don't reset cursor to start of line when moving around
set nrformats=hex              " for C-a and C-x. recognize '0x' prefix as hex
set scrolljump=1               " lines to scroll when cursor leaves screen
set scrolloff=1                " start scrolling when 8 lines away from margins
set updatetime=4000            " swap file writes and CursorHold autocmd. weird fold closing problem
set encoding=utf8              " new files use utf-8 encoding by default
set ffs=unix,dos,mac           " new files use unix line endings by default
set timeout
set timeoutlen=3000
set ttimeoutlen=100
if !has('nvim')
  set cryptmethod=blowfish     " more secure encryption for vim -x
endif
set switchbuf=usetab           " look to see if buffer is already open in another window or tab
set formatoptions-=r           " don't continue comment when hitting enter in insert mode
set formatoptions-=o           " don't automatically continue comment when hitting o in normal mode
set guioptions-=m              " hide gui menu bar
set guioptions-=T              " hide gui toolbar
set guioptions-=r              " hide gui righthand scrollbar
set guioptions-=e              " use regular tabline
set guioptions-=L              " no left scrollbar
set virtualedit=block          " allow visual block mode to move to where there aren't actually characters
set noswapfile                 " seriously who needs them
set tags=./.tags;              " search for .tags file upward (:h file-searching)
set previewheight=20
set listchars=tab:▸\ ,trail:·,extends:>,eol:¶
set dictionary=/usr/share/dict/words  " dictionary completion with <C-X><C-K>
set suffixesadd+=.py,.rb       " suffixes to attempt to use for gf command
set path+=./**
set shell=bash
if v:version > 703 || v:version == 703 && has("patch541")
  set formatoptions+=j  " delete comment character when joining commented lines
endif
set nojoinspaces        " use only one space after a period when joining lines
syntax on                      " syntax hilighting
syntax sync minlines=256       " speed up syntax hilighting
augroup SyntaxSync
  autocmd BufReadPost syntax sync fromstart
augroup END
let g:no_ocaml_maps = 1
if executable('ag')
  set grepprg=ag\ --nogroup\ --nocolor
endif
" }}}
" Completion options {{{
set completeopt=longest,menuone
" hitting enter when completion menu is visible selects item, not used right now due to neocomplete
" inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
" }}}
" Fold {{{
" zf#j manually folds # lines, or zf in visual mode selection.
set foldnestmax =1   " folds only one level deep
set foldmethod  =manual
augroup SyntaxFold
  autocmd BufWinEnter    *.java           set foldnestmax=2 foldlevel=1
  autocmd BufWinEnter    *.c,*.cpp,*.java set foldmethod=syntax " define syntax folds when file loads
  autocmd InsertEnter    *.c,*.cpp,*.java set foldmethod=manual " once we start typing, using manual folds
augroup END
" }}}
" Tab/Indent {{{
set autoindent      " auto indent line to match above line when hitting enter
"set cindent        " newer and better smartindent
set smarttab        " make tabs more consistent with softtabstop
set shiftwidth  =4  " amount of whitespace to insert or remove using normal mode indentation commands
set softtabstop =4  " amount of whitespace deleted by backspace
set tabstop     =4  " width of tab character
set shiftround      " indent by multiples of shiftwidth
set expandtab       " use spaces instead of tabs
set linebreak       " wrap lines at nice points
set textwidth=0     " disables textwidth

" Set tabstop, softtabstop and shiftwidth to the same value
command! -nargs=* Stab call Stab()
function! Stab()
  let l:tabstop = 1 * input('set tabstop = softtabstop = shiftwidth = ')
  if l:tabstop > 0
    let &l:sts = l:tabstop
    let &l:ts = l:tabstop
    let &l:sw = l:tabstop
  endif
  echomsg
  call SummarizeTabs()
endfunction
cnoreabbrev stab Stab

function! SummarizeTabs()
  try
    echohl ModeMsg
    echon 'tabstop='.&l:ts
    echon ' shiftwidth='.&l:sw
    echon ' softtabstop='.&l:sts
    if &l:et
      echon ' expandtab'
    else
      echon ' noexpandtab'
    endif
  finally
    echohl None
  endtry
endfunction
" }}}
" Wildmenu {{{
if has("wildmenu")
  set wildmenu                    " turn on wildmenu
  set wildignorecase              " wildmenu doesn't care about case
  set wildmode=longest:full,full
  set wildignore=*.o,*.a,*~,*.pyc " ignore compiled files
  set wildignore+=*.bmp,*.gif,*.ico,*.jpg,*.jpeg,*.mp4,*.mkv,*.avi,*.pdf,*.png,*.mp3
  set wildignore+=*.m4v,*.flv,*.flac,*.wma,*.doc,*.docx,*.ppt,*.pptx,*.m4a,*.m2ts,*.m3u
  set wildignore+=*:2\\,S,*:2\\,RS,*:2\\,FS,*:2\\,,*:2\\,FRS " for mutt
  set wildignore+=.DS_Store,.git,.hg,.svn
  set wildignore+=*~,*.swp,*.tmp
endif
" }}}
" }}}
" Keymaps {{{
" Misc {{{
" always show multiple tag options, <C-w> to open in new window
"nnoremap <C-]> <C-w>g<C-]>
nnoremap <C-]> g<C-]>

" repeat last substitute like :s, but preserve flags
nnoremap & :&&<CR>
xnoremap & :&&<CR>
" }}}
" fix the esc/alt mapping problem in terminal vim {{{
if !has('gui_running')
  set ttimeoutlen=10
  augroup FastEscape
    autocmd!
    autocmd InsertEnter * :set timeoutlen=0
    autocmd InsertLeave * :set timeoutlen=2000
  augroup END
endif
" }}}
" make/run maps with quickrun/vimproc, gm gr {{{
nnoremap <silent> gma :QuickRun make -args all<CR>
nnoremap <silent> gmc :QuickRun make -args clean<CR>
nnoremap <silent> gmm :QuickRun make<CR>
nnoremap <silent> gmk :call vimproc#kill(b:quickrun_pid,9)<CR>
nnoremap          gml :echo vimproc#get_last_errmsg()<CR>
nnoremap <silent> gms :call quickrun#sweep_sessions()<CR>
nnoremap <silent> gmt :call QuickRunTimeToggle()<CR>
nnoremap <silent> gr :QuickRun -mode n -runner vimproc<CR>
vnoremap <silent> gr :QuickRun -mode v -runner vimproc<CR>
" }}}
" misc g maps {{{
nnoremap          gb    gw{gw}
nnoremap          go    :ls<CR>:sb<Space>
nnoremap          gO    :ls<CR>:b<Space>
nnoremap          gs    gnv
nnoremap          g/    :<C-u>OverCommandLine<CR>%s/
xnoremap          g/    :<C-u>OverCommandLine<CR>%s/\%V
nnoremap          g?    :<C-u>OverCommandLine<CR>/
xnoremap          g?    :<C-u>OverCommandLine<CR>/\%V
nnoremap          g;    g;zz
nnoremap          g,    g,zz
" }}}
" generate map for alt and <C-Space> in both vim and gvim {{{
function! Altmap(char)
  if has('gui_running') | return '<A-'.a:char.'>' | else | return '<Esc>'.a:char|endif
endfunction
let g:ctrl_space = has("gui_running") ? "<C-Space>" : "<C-@>"
" }}}
" TODO these are all shit changed default keys M - _ z<CR> {{{
nnoremap M %
onoremap M %
vnoremap M %
" make K do the opposite of J: split lines under the cursor
nnoremap K i<CR><Esc>k$
" nnoremap - 10jzz
" nnoremap _ 10kzz
nnoremap z<CR> zMzvzz
" }}}
" easily toggle command line window with Q {{{
nnoremap Q q:
augroup CmdWindow
  autocmd CmdwinEnter * nnoremap <buffer><silent> Q :q<CR>
augroup END
" }}}
" visual mode increment, search, shift, gV {{{
vnoremap <C-a> :call Increment()<CR>
xnoremap <C-f> <Esc>/\%V
vnoremap < <gv
vnoremap > >gv
nnoremap gV `[v`]
" }}}
" diff[update,put,obtain] gd[upo] {{{
nnoremap gdu :diffupdate<CR>
xnoremap gdp :diffput <BAR> diffupdate<CR>
xnoremap gdo :diffget <BAR> diffupdate<CR>
" }}}
" line yanks Y yl yaa {{{
nnoremap Y y$
nnoremap yl :let c=col(".")<CR>^v$hy:call cursor(line("."),c)<CR>
nnoremap yaa :let c=col(".") <BAR> let l = line(".")<CR>ggyG:call cursor(l,c)<CR>:echo 'yanked whole file'<CR>
" }}}
" c/C/x/X operators go to their own registers instead of unnamedplus register specified by clipboard setting {{{
nnoremap <expr> c v:register == '+' ? '"cc' : 'c'
nnoremap "+c "+c
nnoremap <expr> C v:register == '+' ? '"cC' : 'C'
nnoremap "+C "+C
nnoremap <expr> x v:register == '+' ? '"xx' : 'x'
nnoremap "+x "+x
nnoremap <expr> X v:register == '+' ? '"xX' : 'X'
nnoremap "+X "+X
" }}}
" quickfix maps {{{
augroup QuickFix
  autocmd FileType qf setlocal nosplitbelow nosplitright
  autocmd FileType qf setlocal switchbuf=""
  autocmd FileType qf nnoremap <buffer><silent> <CR> <CR>zvzz
  autocmd FileType qf nnoremap <buffer><silent> t  <C-w><CR><C-w>Tzvzz
  autocmd FileType qf nnoremap <buffer><silent> T  <C-w><CR><C-w>TzvzzgT<C-w>j
  autocmd FileType qf nnoremap <buffer><silent> o  <CR>zvzz
  autocmd FileType qf nnoremap <buffer><silent> O  <CR>zvzz<C-w>j
  autocmd FileType qf nnoremap <buffer><silent> go <CR>:cclose <Bar> lclose<CR>zvzz
  autocmd FileType qf nnoremap <buffer><silent> s  <C-w><CR>zvzz
  autocmd FileType qf nnoremap <buffer><silent> S  <C-w><CR>zvzz<C-w>p
  autocmd FileType qf nnoremap <buffer><silent> v  :let g:qf_height = winheight('.')<CR><C-w><CR><C-w>L<C-w>p<C-w>J:resize <C-r>=g:qf_height<CR><CR><C-w>pzvzz
  autocmd FileType qf nnoremap <buffer><silent> V  :let g:qf_height = winheight('.')<CR><C-w><CR><C-w>L<C-w>p<C-w>J:resize <C-r>=g:qf_height<CR><CR><C-w>pzvzz<C-w>p
  autocmd FileType qf nnoremap <buffer><silent> q  :cclose <Bar> lclose<CR>zz
  autocmd FileType qf nnoremap <buffer><silent> <leader>q  :cclose <Bar> lclose<CR>zz
augroup END
" }}}
" arrow keys {{{
inoremap <up>   <C-O>gk
inoremap <down> <C-O>gj
vnoremap <up>        gk
vnoremap <down>      gj

nnoremap <up>        :resize +2<CR>
nnoremap <left>      :vertical resize -2<CR>
nnoremap <down>      :resize -2<CR>
nnoremap <right>     :vertical resize +2<CR>
" }}}
" Text Object / targets.vim maps {{{
let g:targets_pairs       = '()p {}c []r <>a'
let g:targets_quotes      = "\"d 's `e"

function! Append(type, ...)
    call feedkeys("`]a", 'n')
endfunction

function! Insert(type, ...)
    call feedkeys("`[i", 'n')
endfunction
" }}}
" k and j add to jumplist {{{
nnoremap <expr> k (v:count > 4 ? "m'" . v:count . 'k' : (v:count == 0 ? 'gk' : 'k'))
nnoremap <expr> j (v:count > 4 ? "m'" . v:count . 'j' : (v:count == 0 ? 'gj' : 'j'))
" }}}
" function keys {{{
nnoremap <F1>          :call StripTrailingWhitespace()<CR>
nnoremap <F2>          :set spell!<CR>
" }}}
" defualt (comma) leader maps {{{
" Main {{{
nnoremap <silent> <leader>a    :set opfunc=Append<CR>g@
"                         c    nerdcommenter maps
nnoremap <silent> <leader>d    :Dispatch!<CR>
nnoremap <silent> <leader>e    :lclose<CR>:silent! let g:ToggleList.cmd.copen="copen"<CR>:ToggleQF<CR>
nnoremap <silent> <leader>E    :lclose<CR>:silent! let g:ToggleList.cmd.copen="Copen"<CR>:ToggleQF<CR>
nnoremap <silent> <leader>fe   :FZF<CR>
nnoremap <silent> <leader>fs   :call fzf#run({'tmux_height': '40%', 'sink':'bo sp' })<CR>
nnoremap <silent> <leader>fv   :call fzf#run({ 'tmux_width': winwidth('.') / 2,'sink': 'vert bo sp' })<CR>
nnoremap <silent> <leader>F    :set foldmethod=syntax<CR>:set foldmethod=manual<CR>
"                         g    fugitive and signify maps
nnoremap <silent> <leader>i    :set opfunc=Insert<CR>g@
nnoremap <silent> <leader>l    :cclose<CR>:ToggleLL<CR>
"                         m    make maps
nnoremap <silent> <leader>p    "0p
nnoremap <silent> <leader>P    "0P
nnoremap <silent> <leader>q    :q <Bar> redraw!<CR>
"                         s and t taken by search/todo
nnoremap <silent> <leader>sd   :SDelete<CR><CR>
nnoremap <silent> <leader>sh   :echo map(synstack(line('.'),col('.')),'synIDattr(v:val,"name")')<CR>
nnoremap          <leader>sl   :Session<Space>

nnoremap          <leader>sf   :call SourceCurrentFunction()<CR>
nnoremap          <leader>sv   :source %<CR>
nnoremap          <leader>sC   :source ~/dotfiles/vim/colors/guimiromod.vim<CR>
nnoremap          <leader>sV   :source $MYVIMRC<CR>
vnoremap          <leader>sv   :Source %<CR>

nnoremap <silent> <leader>tv   :tabedit $MYVIMRC<CR>
nnoremap <silent> <leader>u    yyp^v$r
nnoremap <silent> <leader>w    :w!<CR>
nnoremap <silent> <leader>x    :x!<CR>
vnoremap <silent> <leader>y    y`]
nnoremap <silent> <leader>zs   :syntax sync fromstart<CR>

" buffer search
nnoremap <silent> <leader>tt :silent! vimgrep /\CTODO/gj %<CR>
vnoremap <silent> <leader>ss :<C-u>call VSetSearch('/')<CR>:CurBufGrep <C-r>=@/<CR><CR>
nnoremap          <leader>ss :CurBufGrep<Space>
" all buffer search
nnoremap <silent> <leader>to :silent! vimgrep /\CTODO/gj /dev/empty<CR>:BufGrep \CTODO<CR>
vnoremap <silent> <leader>so :<C-u>call VSetSearch('/')<CR>:BufGrep <C-r>=@/<CR><CR>
nnoremap          <leader>so :BufGrep<Space>
" recursive search
nnoremap <silent> <leader>tr :AgOpenQF TODO<CR>
vnoremap <silent> <leader>sr :<C-u>call VSetSearch('/')<CR>gv"sy:Ag -Q <C-r>=@s<CR><CR>
nnoremap          <leader>sr :AgOpenQF<Space>

nmap              <leader><leader>w  <Plug>(choosewin)
nmap              <leader><leader>s  <Plug>(choosewin-swap)
nmap              <leader><leader>a  <Plug>(choosewin-swap-again)
nnoremap <silent> <leader><leader>r  :redraw!<CR>
nnoremap <silent> <leader><leader>d  :Dispatch<CR>
" }}}
" <leader>g[jkht] signify {{{
nnoremap <silent> <leader>ga  :Git add %:p<CR><CR>
nnoremap          <leader>gb  :Gbranch<Space>
nnoremap <silent> <leader>gB  :Gblame<CR>
nnoremap <silent> <leader>gc  :Gcommit --verbose<CR>
nnoremap          <leader>gC  :Gcheckout<Space>
nnoremap <silent> <leader>gd  :Gdiff<CR>
nnoremap          <leader>ge  :Gedit<Space>
nnoremap          <leader>gg  :Ggrep<Space>
nnoremap <silent> <leader>gla :silent Glog -- <Bar> redraw!<CR>
nnoremap <silent> <leader>glf :silent Glog -- % <Bar> redraw!<CR>
nnoremap <silent> <leader>gli :silent Glog <Bar> redraw!<CR>
nnoremap          <leader>gm  :Gmove<Space>
nnoremap <silent> <leader>gp  :Dispatch! git push<CR>
nnoremap <silent> <leader>gr  :Gread<CR>
nnoremap <silent> <leader>gs  :Gstatus<CR>
nnoremap <silent> <leader>gw  :Gwrite<CR>
" }}}
" <leader>m[acfq] Make {{{
nnoremap <leader>ma          :Make! -j4 all<CR>
nnoremap <leader><leader>ma  :Make  -j4 all<CR>
nnoremap <leader>mc          :Make! clean<CR>
nnoremap <leader><leader>mc  :Make  clean<CR>
nnoremap <leader>mf          :Make! -j4 <C-r>=expand('%:r')<CR><CR>
nnoremap <leader><leader>mf  :Make  -j4 <C-r>=expand('%:r')<CR><CR>
nnoremap <leader>mm          :Make! -j4<CR>
nnoremap <leader><leader>mm  :Make  -j4<CR>
" }}}
" }}}
" space leader maps. unite + tabularize {{{
nnoremap <Space>a        :<C-u>Unite -resume -buffer-name=arglist    argument<CR>
nnoremap <Space>b        :<C-u>Unite -resume -buffer-name=buffers    buffer<CR>
nnoremap <Space>d        :<C-u>Unite -resume -buffer-name=tabs       tab:no-current<CR>
nnoremap <Space>f        :<C-u>Unite -resume -buffer-name=files      file<CR>
nnoremap <Space>g        :<C-u>Unite -resume -buffer-name=ag         grep:.<CR>
nnoremap <Space>G        :<C-u>Unite -resume -buffer-name=gist       gist<CR>
nnoremap <Space>h        :<C-u>Unite -resume -buffer-name=help       help<CR>
nnoremap <Space>L        :<C-u>Unite -resume -buffer-name=launcher   launcher<CR>
nnoremap <Space>ol       :<C-u>Unite -resume -buffer-name=lines      line<CR>
nnoremap <Space>oo       :<C-u>Unite -resume -buffer-name=outline    outline<CR>
nnoremap <Space>q        :<C-u>Unite -resume -buffer-name=quickfix   qf<CR>
nnoremap <Space>r        :<C-u>Unite -resume -buffer-name=file_rec   file_rec/async:!<CR>
nnoremap <Space>sl       :<C-u>Unite -resume -buffer-name=sessions   session<CR>
nnoremap <Space>sn       :<C-u>Unite -resume -buffer-name=new_session session/new<CR>
nnoremap <Space>t        :<C-u>Unite -resume -buffer-name=tags       tag<CR>a<BS>
nnoremap <Space>vf       :<C-u>Unite -resume -buffer-name=functions  function<CR>
nnoremap <Space>vm       :<C-u>Unite -resume -buffer-name=mappings   mapping<CR>
nnoremap <Space>vr       :<C-u>Unite -resume -buffer-name=runtimepath runtimepath<CR>
nnoremap <Space>w        :<C-u>Unite -resume -buffer-name=window     window:no-current<CR>
nnoremap <Space><Space>  :<C-u>Unite -resume -buffer-name=sources    source<CR>
nnoremap <Space><CR>     :<C-u>Unite -resume -buffer-name=output     output<CR>
nnoremap <Space>:        :<C-u>Unite -resume -buffer-name=cmdmatch   cmdmatch<CR>

nnoremap <Space>j        :<C-u>Unite          -buffer-name=find    -resume   find:.<CR><Left><Left><Left><Left><Left>i<Right><Right><Right><Right><Right>'**'<Left><Left>
nnoremap <Space>J        :<C-u>Unite          -buffer-name=find    -resume   find:.<CR><Left><Left><Left><Left><Left>i<Right><Right><Right><Right><Right>''<Left>
nnoremap <Space>k        :<C-u>Unite -default-action=sigkill -buffer-name=killproc process<CR>
nnoremap <Space>l        :<C-u>UniteWithInput -buffer-name=locate     locate<CR>

" menus
nnoremap <Space>mm       :<C-u>Unite -resume menu<CR>
nnoremap <Space>mg       :<C-u>Unite -resume -silent -winheight=25 menu:git<CR>
nnoremap <Space>m,       :<C-u>Unite -resume -silent -winheight=30 menu:leader<CR>
nnoremap <Space>mN       :<C-u>Unite -resume -silent               menu:navigation<CR>
nnoremap <Space>mn       :<C-u>Unite -resume -silent               menu:neobundle<CR>
nnoremap <Space>m<Space> :<C-u>Unite -resume -silent -winheight=29 menu:spaceleader<CR>
nnoremap <Space>mv       :<C-u>Unite -resume -silent               menu:vim<CR>


" `:TabFirst =` to align to first equal sign. similar to `:Tabularize /=.*/`
command! -nargs=1 -range TabFirst exec <line1> . ',' . <line2> . 'Tabularize /^[^' . escape(<q-args>, '\^$.[?*~') . ']*\zs' . escape(<q-args>, '\^$.[?*~')
" }}}
" ctrl normal mode {{{
nnoremap <C-w><C-b>         :VimFilerExplorer -find<CR>:redraw!<CR>
nnoremap <C-b>              :VimFiler -find<CR>:redraw!<CR>
nnoremap <C-n>              gt
nnoremap <C-p>              gT
nnoremap <C-w>o             <C-w>o:redraw!<CR>
nnoremap <C-w>s             <C-w>s:redraw!<CR>
nnoremap <C-w>v             <C-w>v:redraw!<CR>
" }}}
" ctrl insert mode {{{
inoremap <C-a>   <Home>
inoremap <C-c>   <Esc><Esc>`^
inoremap <C-e>   <End>
" }}}
" alt normal mode {{{
nnoremap          gH    <C-w>H
nnoremap          gJ    <C-w>J
nnoremap          gK    <C-w>K
nnoremap          gL    <C-w>L
exec 'nnoremap <silent> ' . Altmap('a') . ' :AirlineToggle<CR>'
exec 'nnoremap <silent> ' . Altmap('h') . ' :execute "vertical resize " . (winwidth(0) * 5/6)<CR>'
exec 'nnoremap <silent> ' . Altmap('j') . ' :execute "resize " . (winheight(0) * 5/6)<CR>'
exec 'nnoremap <silent> ' . Altmap('k') . ' :execute "resize " . (winheight(0) * 6/5)<CR>'
exec 'nnoremap <silent> ' . Altmap('l') . ' :execute "vertical resize " . (winwidth(0) * 6/5)<CR>'
exec 'nnoremap <silent> ' . Altmap('m') . ' :match none<CR>'
exec 'nnoremap <silent> ' . Altmap('n') . ' :tabmove +1<CR>'
exec 'nnoremap <silent> ' . Altmap('p') . ' :tabmove -1<CR>'
exec 'nnoremap <silent> ' . Altmap('q') . ' :quitall<CR>'
exec 'nnoremap <silent> ' . Altmap('1') . ' 1gt'
exec 'nnoremap <silent> ' . Altmap('2') . ' 2gt'
exec 'nnoremap <silent> ' . Altmap('3') . ' 3gt'
exec 'nnoremap <silent> ' . Altmap('4') . ' 4gt'
exec 'nnoremap <silent> ' . Altmap('5') . ' 5gt'
exec 'nnoremap <silent> ' . Altmap('6') . ' 6gt'
exec 'nnoremap <silent> ' . Altmap('7') . ' 7gt'
exec 'nnoremap <silent> ' . Altmap('8') . ' 8gt'
exec 'nnoremap <silent> ' . Altmap('9') . ' 9gt'
exec 'nnoremap <silent> ' . Altmap('0') . ' :tablast<CR>'

exec 'nnoremap <silent> ' . Altmap('H') . ' <C-w>H'
exec 'nnoremap <silent> ' . Altmap('J') . ' <C-w>J'
exec 'nnoremap <silent> ' . Altmap('K') . ' <C-w>K'
exec 'nnoremap <silent> ' . Altmap('L') . ' <C-w>L'

" }}}
" alt insert mode {{{
exec 'inoremap ' . Altmap('h') . '   <Left>'
exec 'inoremap ' . Altmap('j') . '   <Down>'
exec 'inoremap ' . Altmap('k') . '   <Up>'
exec 'inoremap ' . Altmap('l') . '   <Right>'
exec 'inoremap ' . Altmap('b') . '   <S-Left>'
exec 'inoremap ' . Altmap('B') . '   <C-Left>'
exec 'inoremap ' . Altmap('w') . '   <S-Right>'
exec 'inoremap ' . Altmap('W') . '   <C-Right>'
" }}}
" slash leader maps. tmuxify {{{
function! GenerateBuildCommand()
  if &filetype == 'c'
    let my_compiler = 'gcc'
  elseif &filetype == 'cpp'
    let my_compiler = 'g++'
  elseif &filetype == 'ocaml'
    let my_compiler = 'ocamlc'
  endif

  return my_compiler . ' ' . shellescape(expand('%:p')) . ' -o ' . shellescape(expand('%:p:r'))
endfunction

function! TmuxifySendLines(count, direction)
  let l = line(".")
  let c = col(".")

  if a:count == 0
    execute 'normal! "vyy'
  else
    execute 'normal! "vy' . a:count . a:direction
  endif

  TxSend(@v)
  call cursor(l, c)
endfunction

nnoremap <silent> \b  :TxSend(GenerateBuildCommand())<CR>
nnoremap <silent> \c  :TxSigInt<CR>
nnoremap <silent> \d  :call tmuxify#pane_send_raw('C-d')<CR>
nnoremap <silent> \j  :<C-u>call TmuxifySendLines(v:count, "j")<CR>
nnoremap <silent> \k  :<C-u>call TmuxifySendLines(v:count, "k")<CR>
nnoremap <silent> \l  :TxClear<CR>
nnoremap <silent> \ma :TxSend('make')<CR>
nnoremap <silent> \mc :TxSend('make clean')<CR>
nnoremap <silent> \o  :TxCreate<CR>
nnoremap <silent> \q  :TxKill<CR>
nnoremap <silent> \r  :TxRun<CR>
nnoremap <silent> \s  "vyy:TxSend(@v)<CR>
vnoremap <silent> \s  "vy:TxSend(@v)<CR>
nnoremap <silent> \w  :call tmuxify#pane_send_raw('C-u')<CR>:TxClear<CR>
nnoremap <silent> \|  :TxSend<CR>
nnoremap <silent> \<CR>  :call tmuxify#pane_send_raw('C-j')<CR>
" }}}
" }}}
function! Open_current_file_dir(args)
  let [args, options] = unite#helper#parse_options_args(a:args)
  let path = expand('%:h')
  let options.path = path
  call unite#start(args, options)
endfunction
nnoremap <leader>F :call Open_current_file_dir('-no-split file')<cr>
nmap <buffer> <bs> <Plug>(unite_delete_backward_path)

" vim: foldmethod=marker foldlevel=1 textwidth=0 softtabstop=2 tabstop=2 shiftwidth=2
