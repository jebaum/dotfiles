" Initial setup {{{
colorscheme default
runtime macros/matchit.vim
set guifont=DejaVuSansMono\ 11
let mapleader = ','
augroup VIMRCMAP
  autocmd!
  autocmd BufRead *vimrc* nnoremap <buffer> z<Space> zMzrzvzz
augroup END
augroup EXPERIMENTAL
  autocmd InsertEnter * set norelativenumber
  autocmd InsertLeave * set relativenumber
augroup END
" Vim-Plug  {{{
if empty(glob("~/.vim/autoload/plug.vim"))
    silent call mkdir(expand("~/.vim/autoload", 1), 'p')
    execute '!curl -fLo '.expand("~/.vim/autoload/plug.vim", 1).' https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
endif

let g:plug_threads = 70
let @p="03df/IPlug 'A':wV:Source:PlugInstall"

call plug#begin('~/.vim/bundle')
Plug 'morhetz/gruvbox'
if has('unix')
  Plug 'Shougo/vimproc.vim', {'do' : 'make'}
  Plug 'int3/vim-extradite' ", {'on': ['Extradite']}
  Plug 'junegunn/gv.vim',    {'on': ['GV']}
  " Plug 'lambdalisue/vim-gita'
  Plug 'jebaum/vim-tmuxify'
endif

if has('python') || has('python3') " pip3 install neovim only sets 'python3' to 1
  Plug 'honza/vim-snippets'
  Plug 'SirVer/ultisnips'
  Plug 'Valloric/MatchTagAlways'
endif

" settings for completion plugins defined in `after/plugin` directory
if has('nvim')
  Plug 'Shougo/deoplete.nvim'
  Plug 'carlitux/deoplete-ternjs'
  set shortmess+=c " helps with completion flicker
else
  Plug 'othree/vim-autocomplpop'
  Plug 'eparreno/vim-l9'
endif
Plug 'bruno-/vim-husk'
Plug 'bruno-/vim-man', {'on': ['Man', 'Vman', 'Mangrep']}
Plug 'christoomey/vim-tmux-navigator'
Plug 'ciaranm/detectindent'
Plug 'dahu/vimple'
Plug 'derekwyatt/vim-scala', {'for': ['scala']}
Plug 'dockyard/vim-easydir'
Plug 'mtth/scratch.vim',     {'on': ['Scratch', 'ScratchInsert', 'ScratchSelection']}
Plug 'gcmt/taboo.vim',       {'on': ['TabooOpen', 'TabooRename', 'TabooReset']}
Plug 'inside/vim-search-pulse'
Plug 'jamessan/vim-gnupg'
" Plug 'jebaum/neosyntax'
Plug 'jreybert/vimagit',     {'on': ['Magit', 'MagitOnly']}
Plug 'junegunn/fzf'
Plug 'junegunn/fzf.vim'
Plug 'junegunn/goyo.vim',    {'on': ['Goyo']}
Plug 'junegunn/limelight.vim'
Plug 'junegunn/vim-easy-align'
Plug 'junegunn/vim-oblique'
Plug 'junegunn/vim-pseudocl'
Plug 'junegunn/rainbow_parentheses.vim', {'on': ['RainbowParentheses', 'RainbowParenthesesColors']}
Plug 'justinmk/vim-dirvish', {'on': ['Dirvish']}
Plug 'justinmk/vim-sneak'
Plug 'kopischke/vim-fetch'
Plug 'kopischke/vim-stay'
Plug 'lambdalisue/vim-gista'
Plug 'lordm/vim-browser-reload-linux', {'on': ['ChromeReload', 'FirefoxReload', 'ChromeReloadStart', 'FirefoxReloadStart', 'ChromeReloadStop', 'FirefoxReloadStop']}
Plug 'Valloric/ListToggle'
Plug 'mhinz/vim-grepper', {'on': ['Grepper', '<Plug>(GrepperOperator)']}
Plug 'mhinz/vim-signify' " do not lazy load
Plug 'mhinz/vim-startify'
Plug 'osyo-manga/vim-anzu'
Plug 'osyo-manga/vim-brightest'
Plug 'osyo-manga/vim-over',  {'on': ['OverCommandLine', 'OverCommandLineMap', 'OverCommandLineNoremap']}
Plug 'scrooloose/nerdcommenter'
if has('nvim')
    Plug 'benekastah/neomake'
else
    Plug 'scrooloose/syntastic'
endif
Plug 'Shougo/unite.vim'      " required for vimfiler
Plug 'Shougo/vinarise.vim',  {'on': ['Vinarise', 'VinariseDump', 'VinariseScript2Hex']}
Plug 'Shougo/vimfiler.vim'
Plug 'talek/obvious-resize', {'on': ['ObviousResizeLeft', 'ObviousResizeDown', 'ObviousResizeUp', 'ObviousResizeRight']}
Plug 'thinca/vim-quickrun',  {'on': 'QuickRun'}
Plug 'tmhedberg/SimpylFold', {'for': 'python'}
Plug 'tommcdo/vim-exchange', {'on': ['<Plug>(Exchange)', '<Plug>(ExchangeClear)', '<Plug>(ExchangeLine)']}
Plug 'tpope/vim-abolish',    {'on': ['Abolish', 'Subvert', 'S']}
Plug 'tpope/vim-eunuch',     {'on': ['Unlink', 'Remove', 'Move', 'Rename', 'Chmod', 'Mkdir', 'Find', 'Locate', 'SudoEdit', 'SudoWrite', 'Wall', 'W']}
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-jdaddy'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-scriptease', {'on': ['Runtime', 'Scriptnames', 'Verbose', 'Time', 'Vedit', 'Vsplit', 'Vtabedit']}
Plug 'tpope/vim-surround'
Plug 'tpope/vim-unimpaired'
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
Plug 'vim-pandoc/vim-pandoc',        {'for': 'pandoc'} " breaks textwidth?
Plug 'vim-pandoc/vim-pandoc-syntax', {'for': 'pandoc'}
Plug 'vim-pandoc/vim-pandoc-after',  {'for': 'pandoc'}
Plug 'vim-scripts/SyntaxRange', {'for': ['markdown', 'pandoc']}
Plug 'wellle/targets.vim'
Plug 'wellle/tmux-complete.vim'
Plug 'Yggdroot/indentLine', {'on': ['IndentLinesEnable', 'IndentLinesDisable', 'IndentLinesReset', 'IndentLinesToggle']}
Plug 'artur-shaik/vim-javacomplete2', {'for': ['java']}
" Plug 'gcavallanti/vim-noscrollbar'
" set statusline=%<%f\ %h%m%r%=%-14.(%l,%c%V%)\ %{noscrollbar#statusline(50,'â– ','â—«',['â—§'],['â—¨'])}

Plug 'pangloss/vim-javascript', {'for': 'javascript'}
Plug 'ternjs/tern_for_vim',     {'for': ['javascript'], 'do': 'npm install' }
Plug 'othree/javascript-libraries-syntax.vim', {'for': 'javascript'}
call plug#end()

let g:gruvbox_invert_selection=0
let g:gruvbox_contrast_dark='medium'
set background=dark
colorscheme gruvbox
" override some defaults
function! TweakColors()
  " current match when hitting n/N to navigate
  highlight ObliqueCurrentMatch     ctermfg=16  ctermbg=40 guifg=#000000 guibg=#00D700
  " current match when actively searching
  highlight ObliqueCurrentIncSearch ctermfg=16  ctermbg=40  guifg=#000000 guibg=#00D700
  " color of search text in command line
  highlight ObliqueLine             ctermfg=229 guifg=#FFFFAF
  " color of matches the cursor isn't on when actively searching
  highlight IncSearch               ctermfg=250 ctermbg=24  guifg=#BCBCBC guibg=#005F87
  " color of matches the cursor isn't on after finished searching
  highlight Search                  ctermfg=255 ctermbg=24  guifg=#EEEEEE guibg=#005F87

  highlight Folded     ctermbg=16                               guibg=#000000
  highlight Function   ctermfg=43                guifg=#00D7AF
  highlight MatchParen ctermfg=16   ctermbg=201  guifg=#000000  guibg=#FF00FF
  highlight Normal     ctermfg=223               guifg=#FFD7AF  guibg=#202020
  highlight SpecialKey ctermfg=231  ctermbg=236  guifg=#FFFFFF  guibg=#303030
  highlight String     ctermfg=46                guifg=#33D933

  " copied from statline.vim
  highlight User1 ctermfg=221  ctermbg=232  cterm=none guifg=#FFD75F  guibg=#080808  gui=none
  highlight User2 ctermfg=47   ctermbg=232  cterm=none guifg=#00FF5F  guibg=#080808  gui=none
  highlight User3 ctermfg=196  ctermbg=232  cterm=bold guifg=#FF0000  guibg=#080808  gui=bold
  highlight User4 ctermfg=49   ctermbg=232  cterm=none guifg=#00FFAF  guibg=#080808  gui=none
  highlight User5 ctermfg=47   ctermbg=232  cterm=none guifg=#00FF5F  guibg=#080808  gui=none
  highlight User6 ctermfg=231  ctermbg=232  cterm=none guifg=#FFFFFF  guibg=#080808  gui=none
  highlight User7 ctermfg=253  ctermbg=232  cterm=none guifg=#DADADA  guibg=#080808  gui=none
  highlight User8 ctermfg=207  ctermbg=232  cterm=none guifg=#FF5FFF  guibg=#080808  gui=none
  highlight User9 ctermfg=208  ctermbg=232  cterm=none guifg=#FF8700  guibg=#080808  gui=none

  let g:vim_search_pulse_color_list = has('gui_running') || (has('nvim') && &termguicolors) ?
        \ ['#3a3a3a', '#444444', '#4e4e4e', '#585858', '#606060'] :
        \ [238, 239, 240, 241, 242, 243, 244, 245, 246]
endfunction
call TweakColors()
augroup TweakColors
  autocmd!
  autocmd Syntax * call TweakColors()
augroup END
" }}}
" }}}
" Misc {{{
" Mail / Mutt {{{
augroup MUTT " spell check, textwidth, F1-3 for wrapping paragraphs in useful ways
  autocmd!
  autocmd BufRead /tmp/mutt-* set tw=72  " for email with mutt
  autocmd BufRead /tmp/mutt-* set spell  " <-- vim 7 required
augroup END
" }}}
" Fix borders of fullscreen GUI {{{
if has('gui_gtk') && has('gui_running')
    let s:border = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'gui')
    exe 'silent !echo ''style "vimfix" { bg[NORMAL] = "' . escape(s:border, '#') . '" }'''.
                \' > ~/.gtkrc-2.0.mine'
    exe 'silent !echo ''widget "vim-main-window.*GtkForm" style "vimfix"'''.
                \' >> ~/.gtkrc-2.0.mine'
endif
" }}}
" Return to last edit position when opening files {{{
augroup ReturnToLast
  autocmd!
  autocmd BufReadPost *
       \ if line("'\"") > 0 && line("'\"") <= line("$") |
       \   exe "normal! g`\"" |
       \ endif
augroup END
" }}}
" Command mode maps and abbreviations {{{
command! CD cd %:p:h
command! SearchCount %s///gn

" common typos
command! -bang Q  :q<bang>
command! -bang QA :qa<bang>
command! -bang Qa :qa<bang>

" use one of these maps in the middle of a search to move, copy, or delete text
cnoremap $t <CR>:t''<CR>
cnoremap $T <CR>:''t.<CR>
cnoremap $m <CR>:m''<CR>
cnoremap $M <CR>:''m.<CR>
cnoremap $d <CR>:d<CR>``
" }}}
" SyntaxRange autocmds {{{
" last parameter is optional and can be any highlight group, determines delimiter colors
augroup SyntaxNotes
  autocmd!
  " for backward compatibility
  autocmd BufEnter *.md,*.page call SyntaxRange#Include('@begin=c@',    '@end=c@',    'c',    'Comment')
  autocmd BufEnter *.md,*.page call SyntaxRange#Include('@begin=cpp@',  '@end=cpp@',  'cpp',  'Comment')
  autocmd BufEnter *.md,*.page call SyntaxRange#Include('@begin=lisp@', '@end=lisp@', 'lisp', 'Comment')
  autocmd BufEnter *.md,*.page call SyntaxRange#Include('@begin=ml@',   '@end=ml@',   'ocaml','Comment')
  autocmd BufEnter *.md,*.page call SyntaxRange#Include('@begin=text@', '@end=text@', 'text', 'Tabline')

  autocmd BufEnter *.md,*.page call SyntaxRange#Include('```c',      '```', 'c',      'Comment')
  autocmd BufEnter *.md,*.page call SyntaxRange#Include('```cpp',    '```', 'cpp',    'Comment')
  autocmd BufEnter *.md,*.page call SyntaxRange#Include('```java',   '```', 'java',   'Comment')
  autocmd BufEnter *.md,*.page call SyntaxRange#Include('```lisp',   '```', 'lisp',   'Comment')
  autocmd BufEnter *.md,*.page call SyntaxRange#Include('```ml',     '```', 'ocaml',  'Comment')
  autocmd BufEnter *.md,*.page call SyntaxRange#Include('```prolog', '```', 'prolog', 'Comment')
  autocmd BufEnter *.md,*.page call SyntaxRange#Include('```python', '```', 'python', 'Comment')
  autocmd BufEnter *.md,*.page call SyntaxRange#Include('```text',   '```', 'text',   'Tabline')
  autocmd BufEnter *.md,*.page call SyntaxRange#Include('```javascript',   '```', 'javascript',   'Comment')
augroup END
" }}}
" FileType autocmds {{{
augroup FileTypeSettings
  autocmd!
  autocmd FileType gitcommit setlocal nocursorline nocursorcolumn
  autocmd FileType lisp setlocal foldmethod=indent foldlevel=0
  autocmd FileType make setlocal noexpandtab shiftwidth=4 tabstop=4
  autocmd FileType ocaml call MapInterpreter('ocaml', 'ocaml')
  autocmd FileType vimfiler setlocal relativenumber
  autocmd BufNewFile,BufRead  .tags set filetype=tags
  autocmd BufNewFile,BufRead *.log  set filetype=log
  autocmd BufRead,BufNewFile *.md set filetype=pandoc
  autocmd FileType tex      nnoremap <buffer> <leader>mv :call system("mupdf " . shellescape(expand('%:p:r')).'.pdf &')<CR>
  autocmd FileType javascript setlocal foldmethod=syntax foldnestmax=5 foldlevel=1
  autocmd FileType java setlocal omnifunc=javacomplete#Complete
augroup END
" }}}
" align quickfix output {{{
augroup QuickfixAlign
  autocmd!
  autocmd BufRead quickfix setl modifiable
            \| silent exe "%!perl -ple '
                \my ($file, $pos, $msg) = split qr{[|]}, $_, 3;
                \my $aligned_pos = sub {
                \  my @p = split qr{[ ]}, shift;
                \  return                                        if @p == 0;
                \  return sprintf q{\\%3s}, @p                   if @p == 1;
                \  return sprintf q{\\%3s \\%s}, @p              if @p == 2;
                \  return sprintf q{\\%3s \\%s \\%2s}, @p        if @p == 3;
                \  return sprintf q{\\%3s \\%s \\%2s \\%-8s}, @p if @p == 4;
                \  return join q{ }, @p;
                \}->($pos);
                \$_ = join q{|}, $file, $aligned_pos, $msg;
            \'"
            \| setl nomodifiable
augroup END
" }}}
" amazon wikiUtil {{{
function s:WikiJobHandler(job_id, data, event)
    if a:event == 'stdout' || a:event == 'stderr'
        let self.output .= join(a:data)
      else
        let self.exitstatus = a:data
        if self.exitstatus == 0
            echo 'wiki node uploaded successfully'
        else
            echom 'problem with wiki upload'
            echom self.output
        endif
      endif
endfunction

function! WikiPut()
    " let summary = input("change summary [or leave blank]: ")
    " if strlen(summary) == 0
        " let summary = ""
    " endif

    let s:callbacks = {
    \ 'on_stdout': function('s:WikiJobHandler'),
    \ 'on_stderr': function('s:WikiJobHandler'),
    \ 'on_exit': function('s:WikiJobHandler'),
    \ 'output' : '',
    \ 'exitstatus': -1
    \ }
    if has('nvim')
        let g:wikijob = jobstart(["/home/local/ANT/jbbaumga/wiki/remoteWikiUtil.sh", "put", expand('%:t')], s:callbacks)
    else
        silent let g:wiki = system("/home/local/ANT/jbbaumga/wiki/remoteWikiUtil.sh put " . shellescape(expand('%:t')))
        let g:exit = v:shell_error
        if g:exit == 0
            echo 'wiki node uploaded successfully'
        else
            echo 'problem with wiki upload. showing g:wiki'
            echo g:wiki
        endif
    endif
endfunction

function! WikiGet()
    let url = input("url: ")
    if strlen(url) == 0
        echoerr 'you goofed'
    else
        silent exe "!./remoteWikiUtil get '" . url . "'"
endfunction

command! WikiPut call WikiPut()
nnoremap ,,w :WikiPut<CR>
" }}}
" generate map for alt and <C-Space> in both vim and gvim {{{
function! Altmap(char)
  if has('gui_running') || has('nvim') | return '<A-'.a:char.'>' | else | return '<Esc>'.a:char|endif
endfunction
function! AltShiftmap(char)
  if has('gui_running') || has('nvim') | return '<A-S-'.a:char.'>' | else | return '<Esc>'.a:char|endif
endfunction
let g:ctrl_space = has("gui_running") ? "<C-Space>" : "<C-@>"
" }}}
" fastfold functionality {{{
augroup FastFold
  autocmd!
  autocmd InsertEnter * let w:lastfdm = &l:foldmethod | setlocal foldmethod=manual
  autocmd InsertLeave * call ResetFolds()
augroup END
function! ResetFolds()
  if exists('w:lastfdm') && &l:foldmethod ==# 'manual'
    let &l:foldmethod= w:lastfdm
  endif
endfunction
" }}}
" }}}
" Functions {{{
" StripWhitespace function {{{
function! StripWhitespace(line1, line2)
    let _s=@/
    let l = line(".")
    let c = col(".")
    execute ':' . a:line1 . ',' . a:line2 . 's/\s\+$//e'
    let @/=_s
    call cursor(l, c)
endfunction

command! -range=% Strip call StripWhitespace(<line1>, <line2>)
" }}}
" CustomMatch function {{{
function! CustomMatch(pattern)
  let search_string = "/" . a:pattern . "/"
  execute 'match MatchTarget ' . search_string
endfunction
command! -nargs=1 MatchText call CustomMatch(<f-args>)
command! -nargs=1 MT        call CustomMatch(<f-args>)
highlight MatchTarget ctermfg=231 ctermbg=124 guifg=#FFFFFF guibg=#AF0000
" }}}
" Location list loop function {{{
function! WrapCommand(window, direction)
  if a:direction == "up"
    try
      execute a:window . 'previous'
    catch /^Vim\%((\a\+)\)\=:E553/
      execute a:window . 'last'
    endtry
  elseif a:direction == "down"
    try
      execute a:window . 'next'
    catch /^Vim\%((\a\+)\)\=:E553/
      execute a:window . 'first'
    endtry
  endif
endfunction

" nnoremap <Home> :call WrapCommand("l", "up")<CR>
" nnoremap <End>  :call WrapCommand("l", "down")<CR>
" }}}
" Visual mode increment function {{{
function! Increment()
  let a = line('.') - line("'<")
  let c = virtcol("'<")
  if a > 0
    execute 'normal! '.c.'|'.a."\<C-a>"
  endif
  normal `<
endfunction
" }}}
" ProcessJSON {{{
function! ProcessJSON()
    %s/\s\+$//e  " strip trailing whitespace
    g/^$/d       " delete empty lines
    %join        " join whole file into one line
    %s/^\s\+//e  " strip any leading whitespace from opening line
    call Stab(2) " set tabstop to 2
    call jdaddy#reformat('jdaddy#outer_pos', 0) " tpope jdaddy
endfunction
command! JSON call ProcessJSON()
" }}}
" Red/Green Bar {{{
function! WideMsg(msg)
  let x=&ruler | let y=&showcmd
  set noruler noshowcmd
  redraw
  echo a:msg
  let &ruler=x | let &showcmd=y
endfunction

function! GreenBar(msg)
  echohl GreenBar
    call WideMsg(a:msg . repeat(" ", &columns - strwidth(a:msg) - 1))
  echohl None
endfunction

function! RedBar(msg)
  echohl RedBar
    call WideMsg(a:msg . repeat(" ", &columns - strwidth(a:msg) - 1))
  echohl None
endfunction
" }}}
" Source that accepts range {{{
function! DetectIfInVimFunction(...)
  " search upward from the current line for the command 'function' to see if we're currently in a function
  " if we find 'endfunction' command before we find 'function', we aren't in a function
  " if we find 'function' first, then search downward for the corresponding 'endfunction'
  " return list of function start and end line numbers if successful, list of -1 if not

  " TODO use search() ? `call search('function!', 'b')'
  let startline   = line('.')
  let currentline = line('.')

  if a:0 != 0
    let iterlimit = a:1
  else
    let iterlimit = 250
  endif

  let i = 0
  while i < iterlimit

    " see if the text 'function' or 'endfunction' is on the current line
    let funmatchpos    = match(getline(currentline), "function!")
    let endfunmatchpos = match(getline(currentline), "endfunction")

    if funmatchpos != -1  " we found the text 'function'
      let funsynlist = map(synstack(currentline, funmatchpos + 1),'synIDattr(v:val,"name")')
      if index(funsynlist, 'vimFuncKey') >= 0 " function start markers are in the VimFuncKey syntax group
        " save the line number of the first line of the function, and reset the search position
        let startfunline = currentline
        let currentline  = startline
      endif
    endif

    if endfunmatchpos != -1 " we found the text 'endfunction'
      let endfunsynlist = map(synstack(currentline, endfunmatchpos + 1),'synIDattr(v:val,"name")')
      if index(endfunsynlist, 'vimCommand') >= 0 " endfunction markers are in the VimCommand syntax group
        if currentline == startline || exists('startfunline')
          " if we started out with the cursor on endfunction, or we've already found a function start
          let endfunline = currentline
        else " we found an endfunction before finding a function start, so we aren't currently in a function
          break
        endif
      endif
    endif

    let i += 1

    if exists('startfunline') && exists('endfunline')
      return [startfunline, endfunline]
    elseif exists('startfunline')
      " we found the function start, so now we want to search downward
      let currentline += 1
    else
      let currentline -= 1
    endif
  endwhile
  return [-1, -1]
endfunction

function! SourcePart(line1, line2)
   let tmp = @z
   silent exec a:line1.",".a:line2."yank z"
   let @z = substitute(@z, '\n\s*\\', '', 'g')
   @z
   let @z = tmp
endfunction

function! SourceCurrentFunction()
  let [startfunline, endfunline] = DetectIfInVimFunction()
  if startfunline != -1
    call SourcePart(startfunline, endfunline)
    echo 'sourced ' . strpart(getline(startfunline), strlen('function! '))
  else
    echo 'cursor is not in a function'
  endif
endfunction

" if some argument is given, this command calls built-in command :source with
" given arguments; otherwise calls function SourcePart() which sources
" visually selected lines of the buffer.
command! -nargs=? -bar -range Source if empty("<args>") | call SourcePart(<line1>, <line2>) | else | exec "so <args>" | endif
" }}}
" }}}
" Plugins {{{
" airline {{{
let g:airline_theme='bubblegum'
let g:airline_powerline_fonts          = 1
let g:airline_skip_empty_sections      = 1
let g:airline#extensions#hunks#enabled = 1
" }}}
" anzu {{{
let g:anzu_enable_CursorMoved_AnzuUpdateSearchStatus =1
" }}}
" brightest {{{
augroup DisableBrightestOnStart
    autocmd VimEnter * if exists(':Brightest') | BrightestDisable | endif
augroup END
let g:brightest#highlight = { 'group': 'BrightestCustom' }
highlight BrightestCustom guifg=#000000 guibg=#00FF00
" }}}
" detectindent {{{
let g:detectindent_preferred_expandtab  = 1
let g:detectindent_preferred_indent     = 4
let g:detectindent_max_lines_to_analyse = 1024
" }}}
" deoplete {{{
let g:deoplete#enable_at_startup            = 1
let g:deoplete#enable_smart_case            = 1
let g:deoplete#auto_completion_start_length = 1
let g:deoplete#sources                      = {}
let g:deoplete#sources._                    = ['omni', 'buffer', 'ultisnips']
let g:deoplete#sources.text                 = ['buffer', 'dictionary']
let g:deoplete#sources.pandoc               = ['buffer', 'dictionary']
let g:deoplete#sources.javascript           = ['omni', 'buffer']
let g:deoplete#sources.java                 = ['javacomplete2', 'omni', 'buffer', 'ultisnips']

" https://gregjs.com/vim/2016/configuring-the-deoplete-asynchronous-keyword-completion-plugin-with-tern-for-vim/
if !exists('g:deoplete#omni#input_patterns')
  let g:deoplete#omni#input_patterns = {}
endif
let g:deoplete#omni#input_patterns.javascript = ['[^. \t0-9]\.\w*']
    let g:deoplete#omni#input_patterns.java = [
        \'[^. \t0-9]\.\w*',
        \'[^. \t0-9]\->\w*',
        \'[^. \t0-9]\::\w*',
        \]
    let g:deoplete#omni#input_patterns.jsp = ['[^. \t0-9]\.\w*']
    let g:deoplete#ignore_sources = {}
    let g:deoplete#ignore_sources._ = ['javacomplete2']

" let g:neocomplete#force_omni_input_patterns.javascript = '[^. \t]\.\w*'

" augroup DeopletePclose " close preview window when finishing completion or leaving insert mode
    " autocmd!
    " autocmd InsertLeave,CompleteDone * if pumvisible() == 0 | pclose | endif
" augroup END

augroup DeopleteOmniFuncs
  autocmd!
  " autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
  " autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
  " autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
  autocmd FileType javascript setlocal omnifunc=tern#Complete
  " autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
  " autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
augroup end
" }}}
" easy-align {{{
xmap ga <Plug>(EasyAlign)
nmap ga <Plug>(EasyAlign)
" }}}
" exchange {{{
" need to define default mappings in vimrc for vim-plug lazy loading to work
nmap cx <Plug>(Exchange)
xmap X <Plug>(Exchange)
nmap cxc <Plug>(ExchangeClear)
nmap cxx <Plug>(ExchangeLine)
let g:easy_align_bypass_fold = 1
" }}}
" fugitive {{{
command! -nargs=1 -bar Gbranch   call GitBranch(<f-args>)
function! GitBranch(name)
    execute 'silent Git checkout -b ' . a:name
    redraw!
endfunction

command! -nargs=1 -bar Gcheckout   call GitCheckout(<f-args>)
function! GitCheckout(name)
    execute 'silent Git checkout ' . a:name
    redraw!
endfunction

autocmd User fugitive  " .. to go back up to parent directory when browsing git tree
  \ if fugitive#buffer().type() =~# '^\%(tree\|blob\)$' |
  \   nnoremap <buffer> .. :edit %:h<CR> |
  \ endif

autocmd BufReadPost fugitive://* set bufhidden=delete  " stop fugitive from making tons of buffers
" }}}
" fzf {{{
let g:fzf_launcher='urxvt -e sh -c %s' " TODO change to st
" }}}
" gista {{{
let g:gista#post_private = 1
" }}}
" grepper {{{
let g:grepper = {}
let g:grepper.tools  = ['ag', 'git', 'grep']
let g:grepper.open   = 1
let g:grepper.jump   = 0
let g:grepper.switch = 0
" }}}
" goyo {{{
let g:goyo_width  = '100%'
let g:goyo_height = '100%'
augroup Goyo
    autocmd!
    autocmd! User GoyoEnter nested call <SID>goyo_enter()
    autocmd! User GoyoLeave nested call <SID>goyo_leave()
augroup END
function! s:goyo_enter()
  " silent !tmux set status off
  set noshowmode
  set noshowcmd
  set scrolloff=999
  Limelight
endfunction

function! s:goyo_leave()
  " silent !tmux set status on
  set showmode
  set showcmd
  set scrolloff=1
  call TweakColors()
  Limelight!
endfunction
" }}}
" indentline {{{
let g:indentLine_char='â”‚'
" }}}
" limelight {{{
let g:limelight_conceal_ctermfg = 240
" }}}
" listtoggle {{{
let g:lt_quickfix_list_toggle_map = '<leader>e'
let g:lt_location_list_toggle_map = '<leader>l'
" }}}
" match tag {{{
let g:mta_filetypes = {
    \ 'html' : 1,
    \ 'xhtml' : 1,
    \ 'xml' : 1,
    \ 'jinja' : 1,
    \ 'php' : 1,
    \}
" }}}
" matchparen {{{
" let g:loaded_matchparen = 1 put this in neovim remote plugin!
augroup MatchParenTimeout
    autocmd!
    autocmd BufEnter * call SetMatchParenTimeout()
augroup END
function! SetMatchParenTimeout()
    let bytes = line2byte(line('$') + 1)
    if bytes > 1000000
        let b:matchparen_timeout = 1
        let b:matchparen_insert_timeout = 1
        setlocal nocursorline nocursorcolumn " TODO conflicts with general cursorline autocmd used in all bufs
        " TODO also turn off anzu here
    endif
endfunction
" }}}
" neomake {{{
if has('nvim')
    augroup NeoMakeAutoRun
        autocmd!
        autocmd! BufWritePost *.js Neomake
    augroup END
    let g:neomake_javascript_jshint_maker = {
        \ 'args': ['--verbose'],
        \ 'errorformat': '%A%f: line %l\, col %v\, %m \(%t%*\d\)',
        \ }
    let g:neomake_javascript_enabled_makers = ['jshint']
endif
" }}}
" nerdcommenter {{{
let NERDSpaceDelims     = 1
let NERDCompactSexyComs = 0
" }}}
" netrw {{{
let g:netrw_bufsettings = 'noma nomod nu nobl nowrap ro'
" }}}
" oblique {{{
let g:oblique#incsearch_highlight_all=1
let g:oblique#clear_highlight = 1
" map n <Plug>(Oblique-n!)<Plug>(anzu-update-search-status)zv<Plug>Pulse
" map N <Plug>(Oblique-N!)<Plug>(anzu-update-search-status)zv<Plug>Pulse

" nnoremap <expr> n 'Nn'[v:searchforward]
" nnoremap <expr> N 'nN'[v:searchforward]
map n <Plug>(Oblique-n!)
map N <Plug>(Oblique-N!)

augroup Oblique
  autocmd! User Oblique
  autocmd! User ObliqueStar
  autocmd! User ObliqueRepeat
  " TODO make sure the anzu command and pulse function exist, just in case
  " also do I even want these? makes the search pattern flash in the command line
  " instead of just updating the anzu count
  autocmd User Oblique       AnzuUpdateSearchStatus | call search_pulse#Pulse() | normal! zv
  autocmd User ObliqueStar   AnzuUpdateSearchStatus | call search_pulse#Pulse() | normal! zv
  autocmd User ObliqueRepeat AnzuUpdateSearchStatus | call search_pulse#Pulse() | normal! zv
augroup END
" }}}
" pandoc {{{
augroup PandocMaps
  autocmd!
  autocmd filetype pandoc nnoremap <buffer><silent><expr> gc ":set cole=" . (&cole != 0 ? "0" : "2") . "<CR>"
augroup END
" let g:pandoc#syntax#codeblocks#embeds#langs = ["ruby", "c"]  " achieve same affect as SyntaxRange
let g:pandoc#folding#level = 1
let g:pandoc#formatting#textwidth = 80
let g:pandoc#folding#fdc = 0 " foldcolumn width
let g:pandoc#modules#disabled = ["folding"]
let g:pandoc#after#modules#enabled = ["ultisnips", "unite"]
" }}}
" quickrun {{{
let g:quickrun_config         = {}  " initialize dictionary
let g:quickrun_config._       = {'runner':'vimproc', 'runner/vimproc/updatetime':'250','hook/getpid/enable':'1'} " _ is fallback default value
let g:quickrun_config.generic = {'exec':'%c %a'}    " any arbitrary -command and -args, e.g. `QuickRun generic -command ls -args '-al ~'`
let g:quickrun_config.make    = {'exec':'make %a','runner':'vimproc','outputter':'quickfix'}
let g:quickrun_config.pandoc  = {'exec':'pandoc %a','runner':'vimproc','outputter':'quickfix','hook/markdown/enable':'1'}
let g:quickrun_config.python  = {'cmdopt':'-u','runner':'vimproc'}      " prevent python from buffering output
let g:quickrun_config.latex   = {'exec':'rubber %a','runner':'vimproc','outputter':'quickfix','hook/markdown/enable':'1'}

function! QuickRunSplit()
    " figure out what to prepend to :split command for buffer output based on current window size
    return winwidth(0) * 2 < winheight(0) * 5 ? "15" : "vertical 45"
endfunction

function! QuickRunTimeToggle()
  if !has_key(g:quickrun_config['_'], 'hook/time/enable')
    let g:quickrun_config['_']['hook/time/enable'] = '0'
  endif
  if g:quickrun_config['_']['hook/time/enable'] == '0'
    let g:quickrun_config['_']['hook/time/enable'] = '1'
    echo 'enabled time hook'
  else
    let g:quickrun_config['_']['hook/time/enable'] = '0'
    echo 'disabled time hook'
  endif
endfunction
" }}}
" scratch {{{
let g:scratch_filetype = 'vim'
" }}}
" search-pulse {{{
let g:vim_search_pulse_mode = 'pattern'
" XXX the speed with which this actually happens seems to depend on the size
" of the buffer currently displayed. also affected by if folds are closed.
" some kind of very slow redrawing being done?

" let g:vim_search_pulse_disable=0 " toggle this on huge buffers?
" TODO pulse seems to do some kind of intelligent interrupting of the drawing loop
" if you hit n again while it's still in the middle of the loop
" i should figure out how that's done and reimplement a simpler version that
" just does cursor line /column flashing, instead of arbitrary patterns
let g:vim_search_pulse_duration = 50
let g:vim_search_pulse_disable_auto_mappings = 1
let g:vim_search_pulse_color_list = has('gui_running') || (has('nvim') && &termguicolors) ?
        \ ['#3a3a3a', '#444444', '#4e4e4e', '#585858', '#606060'] :
        \ [238, 239, 240, 241, 242, 243, 244, 245, 246]
augroup Pulse
    autocmd! User PrePulse
    autocmd! User PostPulse
    autocmd  User PrePulse  set cursorcolumn
    autocmd  User PostPulse set nocursorcolumn
augroup END

" }}}
" signify {{{
let g:signify_disable_by_default = 0            " disable run by default
let g:signify_vcs_list           = [ 'git' ]    " I only use git for now
let g:signify_sign_change        = '~'
let g:signify_sign_show_count = 1
nnoremap <leader>gh :SignifyToggleHighlight<CR>
nnoremap <leader>gt :SignifyToggle<CR>
nnoremap <leader>gf :SignifyFold<CR>
nmap ]c             <Plug>(signify-next-hunk)
nmap [c             <Plug>(signify-prev-hunk)
" }}}
" sneak  {{{
let g:sneak#use_ic_scs = 1
let g:sneak#s_next = 0
nmap f <Plug>Sneak_f
nmap F <Plug>Sneak_F
xmap f <Plug>Sneak_f
xmap F <Plug>Sneak_F
omap f <Plug>Sneak_f
omap F <Plug>Sneak_F
nmap t <Plug>Sneak_t
nmap T <Plug>Sneak_T
xmap t <Plug>Sneak_t
xmap T <Plug>Sneak_T
omap t <Plug>Sneak_t
omap T <Plug>Sneak_T

" nnoremap <expr> ; getcharsearch().forward ? ';' : ','
" nnoremap <expr> , getcharsearch().forward ? ',' : ';'
let g:sneak#streak = 0
nmap <silent> <expr> ; sneak#state().reverse ? '<Plug>SneakPrevious' : '<Plug>SneakNext'
omap <silent> <expr> ; sneak#state().reverse ? '<Plug>SneakPrevious' : '<Plug>SneakNext'
xmap <silent> <expr> ; sneak#state().reverse ? '<Plug>SneakPrevious' : '<Plug>SneakNext'
exec 'nmap <silent> <expr> '.Altmap(';').' sneak#state().reverse ? "<Plug>SneakNext" : "<Plug>SneakPrevious"'
exec 'omap <silent> <expr> '.Altmap(';').' sneak#state().reverse ? "<Plug>SneakNext" : "<Plug>SneakPrevious"'
exec 'xmap <silent> <expr> '.Altmap(';').' sneak#state().reverse ? "<Plug>SneakNext" : "<Plug>SneakPrevious"'
" }}}
" startify {{{
let g:startify_list_order        = ['bookmarks']
let g:startify_bookmarks         = [ '~/dotfiles/vim/vimrc', '~/Dropbox/todo/TODO.txt' ]
let g:startify_files_number      = 7
let g:startify_session_detection = 1 " show session when Session.vim is found in current directory
let g:startify_session_autoload  = 0 " opening directories with a Session.vim will have it auto load
let g:startify_change_to_dir     = 1 " when opening file or bookmark, change to its directory
let g:startify_custom_indices    = ['a','f','h','j','k','l','w','r','u','o','p','z','x','n','m']
if has('nvim')
  let g:startify_custom_header     = [
    \ '    /\\\\\     /\\\  /\\\        /\\\  /\\\\\\\\\\\  /\\\\            /\\\\       ',
    \ '    \/\\\\\\   \/\\\ \/\\\       \/\\\ \/////\\\///  \/\\\\\\        /\\\\\\      ',
    \ '     \/\\\/\\\  \/\\\ \//\\\      /\\\      \/\\\     \/\\\//\\\    /\\\//\\\     ',
    \ '      \/\\\//\\\ \/\\\  \//\\\    /\\\       \/\\\     \/\\\\///\\\/\\\/ \/\\\    ',
    \ '       \/\\\\//\\\\/\\\   \//\\\  /\\\        \/\\\     \/\\\  \///\\\/   \/\\\   ',
    \ '        \/\\\ \//\\\/\\\    \//\\\/\\\         \/\\\     \/\\\    \///     \/\\\  ',
    \ '         \/\\\  \//\\\\\\     \//\\\\\          \/\\\     \/\\\             \/\\\ ',
    \ '          \/\\\   \//\\\\\      \//\\\        /\\\\\\\\\\\ \/\\\             \/\\\',
    \ '           \///     \/////        \///        \///////////  \///              \///',
    \ '',
    \ '',
    \ ]
else
  let g:startify_custom_header     = [
    \ '    /\\\        /\\\   /\\\\\\\\\\\   /\\\\            /\\\\  ',
    \ '    \/\\\       \/\\\  \/////\\\///   \/\\\\\\        /\\\\\\  ',
    \ '     \//\\\      /\\\       \/\\\      \/\\\//\\\    /\\\//\\\  ',
    \ '       \//\\\    /\\\        \/\\\      \/\\\\///\\\/\\\/ \/\\\  ',
    \ '         \//\\\  /\\\         \/\\\      \/\\\  \///\\\/   \/\\\  ',
    \ '           \//\\\/\\\          \/\\\      \/\\\    \///     \/\\\  ',
    \ '             \//\\\\\           \/\\\      \/\\\             \/\\\  ',
    \ '               \//\\\         /\\\\\\\\\\\  \/\\\             \/\\\  ',
    \ '                 \///         \///////////   \///              \///   ',
    \ '',
    \ '',
    \ ]
endif
" }}}
" syntastic {{{
if executable('clang')
  let g:syntastic_c_compiler               = 'clang'
  let g:syntastic_cpp_compiler             = 'clang++'
endif
let g:syntastic_c_compiler_options       = ' -Wall -Wextra'
let g:syntastic_cpp_compiler_options     = ' -Wall -Wextra'

let g:syntastic_java_javac_config_file_enabled = 1
" for allowing syntastic to find symbols in java classpath, put this in .syntastic_javac_config. must be in cwd
" let g:syntastic_java_javac_custom_classpath_command = "brazil-path testlib.classpath | gawk 'BEGIN {RS=\":\"} {print $1;}' | tr '\n' ':'"

let g:syntastic_check_on_open            = 1
let g:syntastic_check_on_wq              = 0
let g:syntastic_aggregate_errors         = 1 " display all errors
let g:syntastic_always_populate_loc_list = 1 " always put detecter errors in location list
let g:syntastic_error_symbol             = 'âœ—âœ—'
let g:syntastic_warning_symbol           = 'âš âš '
let g:syntastic_stl_format               = '[%E{E:%fe-%e}%B{|}%W{W:%fw-%w}]'
" }}}
" taboo {{{
" let g:taboo_tab_format = "%N %1a%m "
let g:taboo_tab_format = "%N %f%m "
" }}}
" tern {{{
if exists('g:plugs["tern_for_vim"]')
  let g:tern_show_argument_hints   = 'on_hold'
  let g:tern_show_signature_in_pum = 1
  let g:tern_request_timeout       = 1
  let g:tern#command               = ['tern']
endif
" }}}
" tmuxify {{{
let g:tmuxify_custom_command = 'tmux split-window -dp 25'
let g:tmuxify_map_prefix = ''
let g:tmuxify_run = {
      \ 'sh':     'bash %',
      \ 'python': 'python %',
      \ 'ocaml':  'ocaml %',
      \ 'clisp':  'clisp %',
\}
" }}}
" ultisnips {{{
let g:UltiSnipsExpandTrigger       = "<C-l>"
let g:UltiSnipsJumpForwardTrigger  = "<C-l>"
let g:UltiSnipsJumpBackwardTrigger = "<C-h>"
let g:UltiSnipsListSnippets        = "<C-f>"
let g:snips_author                 = 'James Baumgarten'
" }}}
" vimple {{{
let g:vimple_init_vn = 0 " vimple has a dumb version check that breaks in neovim
" }}}
" }}}
" General {{{
" Set options {{{
set number                     " show line numbers
set relativenumber             " use relative line numbers
set exrc                       " allow directory specific .vimrc files
set secure                     " prevent directory specific .vimrcs from doing malicious things
set lazyredraw                 " don't redraw the screen w ile executing macros
set clipboard=unnamed          " by default, * system clipboard
set titlestring=%t\            " file name
set title titlelen=150         " max length of title string
set backspace=indent,eol,start " allow backspace in insert mode
set esckeys                    " make numpad work
set autoread                   " reload files changed outside of vim
set splitbelow                 " splits open below
set splitright                 " vsplits open on right
set hidden                     " allows navigating away from buffers with unsaved changes
set fillchars=""               " no dashes in folds or vertical bars in vsplits
set noruler                    " don't show the ruler
set laststatus=2               " always display the statusline
set history=10000              " length of command history
set showmode                   " show what mode we're in on the bottom line
set showcmd                    " show current command or visual selection info in bottom line
set cmdwinheight=10            " height of command line window
set showmatch                  " flash to matching paren when typing
set matchtime=3                " tenths of a second to flash to matching paren
set incsearch                  " find as you type
set hlsearch                   " hilight search terms
set magic                      " change how backslashes are handled in searches
" TODO: undofile, undo/backupdir, etc
set ignorecase                 " case insensitive search by default
set fileignorecase             " ignore case in commands like :buffer
set smartcase                  " case sensitive search if search contains uppercase letter
set nostartofline              " don't reset cursor to start of line when moving around
set nrformats=hex              " for C-a and C-x. recognize '0x' prefix as hex
set scrolljump=1               " lines to scroll when cursor leaves screen
set scrolloff=1                " start scrolling when 8 lines away from margins
set updatetime=4000            " swap file writes and CursorHold autocmd. weird fold closing problem
set encoding=utf8              " new files use utf-8 encoding by default
set ffs=unix,dos,mac           " new files use unix line endings by default
set timeout
set timeoutlen=3000
set ttimeoutlen=100
if !has('nvim')
  set restorescreen=on         " restore screen contents on exit
  set ttyfast                  " redraw screen faster
  set cryptmethod=blowfish     " more secure encryption for vim -x
else
  set termguicolors
endif
set switchbuf=usetab           " look to see if buffer is already open in another window or tab
set formatoptions-=r           " don't continue comment when hitting enter in insert mode
set formatoptions-=o           " don't automatically continue comment when hitting o in normal mode
set guioptions-=m              " hide gui menu bar
set guioptions-=T              " hide gui toolbar
set guioptions-=r              " hide gui righthand scrollbar
set guioptions-=e              " use regular tabline
set guioptions-=L              " no left scrollbar
set virtualedit=block          " allow visual block mode to move to where there aren't actually characters
set noswapfile                 " seriously who needs them
set tags=./.tags;              " search for .tags file upward (:h file-searching)
set previewheight=20
set viewoptions=cursor,folds,slash,unix " vim-stay configuration
set cursorline
set mouse=                     " disable mouse
augroup CursorLine
    autocmd!
    autocmd BufEnter,WinEnter * setlocal cursorline
    autocmd BufLeave,WinLeave * setlocal nocursorline
augroup END
set listchars=tab:â–¶-,trail:â€¢,extends:>,eol:Â¬
set dictionary=/usr/share/dict/words  " dictionary completion with <C-X><C-K>
set suffixesadd+=.py,.rb       " suffixes to attempt to use for gf command
set path+=./**
set shell=zsh
set modeline                   " debian.vim defaults in ubuntu 12.04 unset this
if v:version > 703 || v:version == 703 && has("patch541")
  set formatoptions+=j  " delete comment character when joining commented lines
endif
set nojoinspaces        " use only one space after a period when joining lines
syntax sync minlines=10        " speed up syntax hilighting
syntax sync maxlines=100       " speed up syntax hilighting
set synmaxcol=500
augroup SyntaxSync
  autocmd!
  autocmd BufEnter * syntax sync fromstart
augroup END
let g:no_ocaml_maps = 1
if executable('ag')
  set grepprg=ag\ --nogroup\ --nocolor
endif
filetype plugin indent on
let $NVIM_TUI_ENABLE_CURSOR_SHAPE=1
" }}}
" Completion options {{{
set completeopt=longest,menuone
" hitting enter when completion menu is visible selects item, not used right now due to neocomplete
inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
" }}}
" Fold {{{
" zf#j manually folds # lines, or zf in visual mode selection.
set foldnestmax=1   " folds only one level deep
set foldmethod =manual
set foldlevel  =1
augroup SyntaxFold
  autocmd!
  autocmd BufWinEnter    *.java           set foldnestmax=2 foldlevel=1
  autocmd BufWinEnter    *.c,*.cpp,*.java set foldmethod=syntax " define syntax folds when file loads
  autocmd InsertEnter    *.c,*.cpp,*.java set foldmethod=manual " once we start typing, using manual folds
augroup END
" }}}
" Tab/Indent {{{
set autoindent      " auto indent line to match above line when hitting enter
"set cindent        " newer and better smartindent
set smarttab        " make tabs more consistent with softtabstop
set shiftwidth =4   " amount of whitespace to insert or remove using normal mode indentation commands
set softtabstop=-1  " amount of whitespace deleted by backspace. -1 means use value of 'shiftwidth'
set tabstop    =4   " width of tab character
set shiftround      " indent by multiples of shiftwidth
set expandtab       " use spaces instead of tabs
set linebreak       " wrap lines at nice points
set textwidth=0     " disables textwidth

" Set tabstop, softtabstop and shiftwidth to the same value
command! -nargs=* Stab call Stab()
function! Stab(...)
  if a:0 == 1
    let l:tabstop = 1 * a:1
  else
    let l:tabstop = 1 * input('set tabstop = softtabstop = shiftwidth = ')
  endif
  if l:tabstop > 0
    let &l:sts = l:tabstop
    let &l:ts = l:tabstop
    let &l:sw = l:tabstop
  endif
  echomsg
  call SummarizeTabs()
endfunction
" cnoreabbrev stab Stab

function! SummarizeTabs()
  try
    echohl ModeMsg
    echon 'tabstop='.&l:ts
    echon ' shiftwidth='.&l:sw
    echon ' softtabstop='.&l:sts
    if &l:et
      echon ' expandtab'
    else
      echon ' noexpandtab'
    endif
  finally
    echohl None
  endtry
endfunction
" }}}
" Wildmenu {{{
if has("wildmenu")
  set wildmenu                    " turn on wildmenu
  set wildignorecase              " wildmenu doesn't care about case
  set wildmode=longest:full,full
  set wildignore=*.o,*.a,*~,*.pyc " ignore compiled files
  set wildignore+=*.bmp,*.gif,*.ico,*.jpg,*.jpeg,*.mp4,*.mkv,*.avi,*.pdf,*.png,*.mp3
  set wildignore+=*.m4v,*.flv,*.flac,*.wma,*.doc,*.docx,*.ppt,*.pptx,*.m4a,*.m2ts,*.m3u
  set wildignore+=*:2\\,S,*:2\\,RS,*:2\\,FS,*:2\\,,*:2\\,FRS " for mutt
  set wildignore+=.DS_Store,.git,.hg,.svn
  set wildignore+=*~,*.swp,*.tmp
endif
" }}}
" }}}
" Keymaps {{{
" Misc {{{
" always show multiple tag options, <C-w> to open in new window
"nnoremap <C-]> <C-w>g<C-]>
nnoremap <C-]> g<C-]>
nnoremap <BS> :<C-U>OverCommandLine<CR>%s/\V\<lt><c-r><c-w>\>//g<left><left>
nnoremap H ^
nnoremap L g_
" }}}
" fix the esc/alt mapping problem in terminal vim {{{
if !has('gui_running')
  set ttimeoutlen=10
  augroup FastEscape
    autocmd!
    autocmd InsertEnter * set timeoutlen=0 ttimeoutlen=-1
    autocmd InsertLeave * set timeoutlen=2000
  augroup END
endif
" }}}
" misc g maps {{{
nnoremap          go    :ls<CR>:sb<Space>
nnoremap          gO    :ls<CR>:b<Space>
nnoremap          gp    gw{gw}
nnoremap          gs    gnv
nnoremap          g/    :<C-u>OverCommandLine<CR>%s/
xnoremap          g/    :<C-u>OverCommandLine<CR>%s/\%V
nnoremap          g?    :<C-u>OverCommandLine<CR>/
xnoremap          g?    :<C-u>OverCommandLine<CR>/\%V
nnoremap          g;    g;zz
nnoremap          g,    g,zz
" }}}
" changed default keys M - _ K {{{
nnoremap M %
onoremap M %
vnoremap M %
" make K do the opposite of J: split lines under the cursor
nnoremap K i<CR><Esc>k$
nnoremap - 10jzz
nnoremap _ 10kzz
" }}}
" easily toggle command line window with Q {{{
nnoremap Q q:
augroup CmdWindow
  autocmd!
  autocmd CmdwinEnter * nnoremap <buffer><silent> Q :q<CR>
  autocmd CmdwinEnter * nnoremap <buffer><silent> <C-c> <Esc>
augroup END
" }}}
" visual mode increment, search, shift, gV {{{
vnoremap <C-a> :call Increment()<CR>
xnoremap <C-f> <Esc>/\%V
nnoremap gV `[v`]
" }}}
" diff[update,put,obtain] gd[upo] {{{
nnoremap gdu :diffupdate<CR>
xnoremap gdp :diffput <BAR> diffupdate<CR>
xnoremap gdo :diffget <BAR> diffupdate<CR>
" }}}
" line yanks Y yl yaa {{{
nnoremap Y y$
nnoremap yl :let c=col(".")<CR>^v$hy:call cursor(line("."),c)<CR>
nnoremap yaa :let c=col(".") <BAR> let l = line(".")<CR>ggyG:call cursor(l,c)<CR>:echo 'yanked whole file'<CR>
" }}}
" c/C/x/X operators go to own registers instead of unnamed[plus] register specified by 'clipboard' {{{
nnoremap <expr> c (v:register == '+' \|\| v:register == '*') ? '"cc' : 'c'
nnoremap "+c "+c
nnoremap "*c "*c
nnoremap <expr> C (v:register == '+' \|\| v:register == '*') ? '"cC' : 'C'
nnoremap "+C "+C
nnoremap "*C "*C
nnoremap <expr> x (v:register == '+' \|\| v:register == '*') ? '"xx' : 'x'
nnoremap "+x "+x
nnoremap "*x "*x
nnoremap <expr> X (v:register == '+' \|\| v:register == '*') ? '"xX' : 'X'
nnoremap "+X "+X
nnoremap "*X "*X
" }}}
" quickfix maps {{{
augroup QuickFix
  autocmd!
  autocmd FileType qf setlocal nosplitbelow nosplitright
  autocmd FileType qf setlocal switchbuf=""
  autocmd FileType qf nnoremap <buffer><silent> <CR> <CR>zvzz
  autocmd FileType qf nnoremap <buffer><silent> t  <C-w><CR><C-w>Tzvzz
  autocmd FileType qf nnoremap <buffer><silent> T  <C-w><CR><C-w>TzvzzgT<C-w>j
  autocmd FileType qf nnoremap <buffer><silent> o  <CR>zvzz
  autocmd FileType qf nnoremap <buffer><silent> O  <CR>zvzz<C-w>j
  autocmd FileType qf nnoremap <buffer><silent> go <CR>:cclose <Bar> lclose<CR>zvzz
  autocmd FileType qf nnoremap <buffer><silent> s  <C-w><CR>zvzz
  autocmd FileType qf nnoremap <buffer><silent> S  <C-w><CR>zvzz<C-w>p
  autocmd FileType qf nnoremap <buffer><silent> v  :let g:qf_height = winheight('.')<CR><C-w><CR><C-w>L<C-w>p<C-w>J:resize <C-r>=g:qf_height<CR><CR><C-w>pzvzz
  autocmd FileType qf nnoremap <buffer><silent> V  :let g:qf_height = winheight('.')<CR><C-w><CR><C-w>L<C-w>p<C-w>J:resize <C-r>=g:qf_height<CR><CR><C-w>pzvzz<C-w>p
  autocmd FileType qf nnoremap <buffer><silent> q  :cclose <Bar> lclose<CR>zz
  autocmd FileType qf nnoremap <buffer><silent> <leader>q  :cclose <Bar> lclose<CR>zz
augroup END
" }}}
" Text Object / targets.vim maps {{{
let g:targets_pairs       = '()b {}c []r <>g'
let g:targets_quotes      = "\"d 's `e"

function! Append(type, ...)
    call feedkeys("`]a", 'n')
endfunction

function! Insert(type, ...)
    call feedkeys("`[i", 'n')
endfunction
" }}}
" k and j add to jumplist {{{
nnoremap <expr> k (v:count > 4 ? "m'" . v:count . 'k' : (v:count == 0 ? 'gk' : 'k'))
nnoremap <expr> j (v:count > 4 ? "m'" . v:count . 'j' : (v:count == 0 ? 'gj' : 'j'))
" }}}
" defualt comma leader maps {{{
" Main {{{
nnoremap <silent> <leader>a    :set opfunc=Append<CR>g@
"                         c    nerdcommenter maps
"                 <leader>e    ListToggle
nnoremap <silent> <leader>F    :set foldmethod=syntax<CR>:set foldmethod=manual<CR>
nmap              <leader>G    <Plug>(GrepperOperator)
xmap              <leader>G    <Plug>(GrepperOperator)
nnoremap <silent> <leader>h    :BrightestToggle<CR>
"                         g    fugitive and signify maps
nnoremap <silent> <leader>i    :set opfunc=Insert<CR>g@
nmap     <silent> <Leader>L    :Limelight!!<CR>
xmap              <Leader>L    <Plug>(Limelight)
"                 <leader>l    ListToggle
nnoremap <silent> <leader>m    :Magit<CR><C-w>T
nnoremap <silent> <leader>p    "0p
nnoremap <silent> <leader>P    "0P
nnoremap <silent> <leader>q    :q <Bar> redraw!<CR>
nnoremap          <leader>sf   :call SourceCurrentFunction()<CR>
nnoremap <silent> <leader>sh   :echo map(synstack(line('.'),col('.')),'synIDattr(v:val,"name")')<CR>
nnoremap          <leader>sv   :source %<CR>
nnoremap          <leader>sV   :source $MYVIMRC<CR>
vnoremap          <leader>sv   :Source %<CR>
nnoremap <silent> <leader>S    :let c=col(".")<CR>V:Source<CR>:call cursor(line("."),c)<CR>
vnoremap <silent> <leader>S    <Esc>:let g:c=col(".")<CR>gv:Source<CR>:call cursor(line("."),g:c)<CR>
nnoremap <silent> <leader>tv   :tabedit $MYVIMRC<CR>
nnoremap <silent> <leader>u    yyp^v$r=
nnoremap <silent> <leader>w    :w!<CR>
nnoremap <silent> <leader>x    :x!<CR>
nnoremap <silent> <leader>zs   :syntax sync fromstart<CR>

nnoremap          <leader>#    :Grepper -tool ag -cword -noprompt<cr>
" }}}
" <leader>g[jkht] signify {{{
nnoremap <silent> <leader>ga  :Git add %:p<CR><CR>
nnoremap          <leader>gb  :Gbranch<Space>
nnoremap <silent> <leader>gB  :Gblame<CR>
nnoremap <silent> <leader>gc  :Gcommit --verbose<CR>
nnoremap          <leader>gC  :Gcheckout<Space>
nnoremap <silent> <leader>gd  :Gdiff<CR>
nnoremap          <leader>ge  :Gedit<Space>
nnoremap          <leader>gg  :Grepper<CR>
nnoremap <silent> <leader>gla :silent Glog -- <Bar> redraw!<CR>
nnoremap <silent> <leader>glf :silent Glog -- % <Bar> redraw!<CR>
nnoremap <silent> <leader>gli :silent Glog <Bar> redraw!<CR>
nnoremap          <leader>gm  :Gmove<Space>
nnoremap <silent> <leader>gr  :Gread<CR>
nnoremap <silent> <leader>gs  :Gstatus<CR>
nnoremap <silent> <leader>gw  :Gwrite<CR>
" }}}
" }}}
" space leader maps. fzf + vim-plug {{{
" TODO go through various fzf.vim functions and figure out which ones to use, how to customize them
let g:fzf_command_prefix = 'FZF' " easy autocompletion, and prevent overlap with ag.vim
nnoremap <silent> <Space>b   :FZFBuffers<CR>
nnoremap          <Space>c   :FZFCommands<CR>
nnoremap <silent> <Space>f   :FZFFiles<CR>
nnoremap <silent> <Space>g   :FZFLines<CR>
nnoremap <silent> <Space>G   :FZFBLines<CR>
nnoremap          <Space>h   :FZFHelptags<CR>
nnoremap <silent> <Space>H   :FZFHistory<CR>
nnoremap          <Space>l   :FZFLocate<Space>
nnoremap <silent> <Space>m   :FZFMarks<CR>
nnoremap <silent> <Space>M   :FZFMaps<CR>
nnoremap          <Space>s   :FZFSnippets<CR>
nnoremap <silent> <Space>t   :FZFTags<CR>
nnoremap <silent> <Space>T   :FZFBTags<CR>
nnoremap <silent> <Space>v   :FZFCommits<CR>
nnoremap <silent> <Space>V   :FZFBCommits<CR>
nnoremap <silent> <Space>w   :FZFWindows<CR>
nnoremap <silent> <Space>x   :FZFAg<CR>
nnoremap          <Space>X   :FZFAg<Space>
nnoremap <silent> <Space>:   :FZFHistory:<CR>
nnoremap <silent> <Space>/   :FZFHistory/<CR>

nnoremap <Space>pi       :PlugInstall<CR>
nnoremap <Space>pu       :PlugUpdate<CR>
nnoremap <Space>pU       :PlugUpgrade<CR>
" }}}
" ctrl normal mode {{{
nnoremap <C-w><C-b>         :VimFilerExplorer -find<CR>:redraw!<CR>
nnoremap <C-b>              :VimFiler -find<CR>:redraw!<CR>
nnoremap <C-n>              gt
nnoremap <C-p>              gT
nnoremap <C-w>o             <C-w>o:redraw!<CR>
nnoremap <C-w>s             <C-w>s:redraw!<CR>
nnoremap <C-w>v             <C-w>v:redraw!<CR>
" }}}
" ctrl insert mode {{{
inoremap <C-a>   <Home>
inoremap <C-c>   <Esc><Esc>`^
inoremap <C-e>   <End>
inoremap <Esc>   <Esc>`^
" }}}
" alt normal mode {{{
" move windows
nnoremap          gh    <C-w>H
nnoremap          gj    <C-w>J
nnoremap          gk    <C-w>K
nnoremap          gl    <C-w>L
exec 'nnoremap <silent> ' . AltShiftmap('H') . ' :execute "ObviousResizeLeft " . (winwidth(0) * 1/6)<CR>'
exec 'nnoremap <silent> ' . AltShiftmap('J') . ' :execute "ObviousResizeDown " . (winheight(0) * 1/6)<CR>'
exec 'nnoremap <silent> ' . AltShiftmap('K') . ' :execute "ObviousResizeUp " . (winheight(0) * 1/6)<CR>'
exec 'nnoremap <silent> ' . AltShiftmap('L') . ' :execute "ObviousResizeRight " . (winwidth(0) * 1/6)<CR>'
exec 'nnoremap <silent> ' . Altmap('h') . ' :execute "ObviousResizeLeft 1"<CR>'
exec 'nnoremap <silent> ' . Altmap('j') . ' :execute "ObviousResizeDown 1"<CR>'
exec 'nnoremap <silent> ' . Altmap('k') . ' :execute "ObviousResizeUp 1"<CR>'
exec 'nnoremap <silent> ' . Altmap('l') . ' :execute "ObviousResizeRight 1"<CR>'
exec 'nnoremap <silent> ' . Altmap('m') . ' :match none<CR>'
exec 'nnoremap <silent> ' . Altmap('n') . ' :tabmove +1<CR>'
exec 'nnoremap <silent> ' . Altmap('p') . ' :tabmove -1<CR>'
exec 'nnoremap <silent> ' . Altmap('q') . ' :quitall<CR>'
exec 'nnoremap <silent> ' . Altmap('1') . ' 1gt'
exec 'nnoremap <silent> ' . Altmap('2') . ' 2gt'
exec 'nnoremap <silent> ' . Altmap('3') . ' 3gt'
exec 'nnoremap <silent> ' . Altmap('4') . ' 4gt'
exec 'nnoremap <silent> ' . Altmap('5') . ' 5gt'
exec 'nnoremap <silent> ' . Altmap('6') . ' 6gt'
exec 'nnoremap <silent> ' . Altmap('7') . ' 7gt'
exec 'nnoremap <silent> ' . Altmap('8') . ' 8gt'
exec 'nnoremap <silent> ' . Altmap('9') . ' 9gt'
exec 'nnoremap <silent> ' . Altmap('0') . ' :tablast<CR>'
" }}}
" alt insert mode {{{
exec 'inoremap ' . Altmap('h') . '   <Left>'
exec 'inoremap ' . Altmap('j') . '   <Down>'
exec 'inoremap ' . Altmap('k') . '   <Up>'
exec 'inoremap ' . Altmap('l') . '   <Right>'
exec 'inoremap ' . Altmap('b') . '   <S-Left>'
exec 'inoremap ' . Altmap('B') . '   <C-Left>'
exec 'inoremap ' . Altmap('w') . '   <S-Right>'
exec 'inoremap ' . Altmap('W') . '   <C-Right>'
" }}}
" slash leader maps. tmuxify {{{
function! TmuxifySendLines(count, direction)
  let l = line(".")
  let c = col(".")

  if a:count == 0
    execute 'normal! "vyy'
  else
    execute 'normal! "vy' . a:count . a:direction
  endif

  TxSend!(@v)
  call cursor(l, c)
endfunction

function! AutoAssociate()
  if !exists('$TMUX')
    let descriptor=systemlist('tmux list-panes -aF "#S:#I.#P"')[0]
    if descriptor == 'failed to connect to server: Connection refused'
      echo "there's no tmux running!"
      return -1
    endif
  else
    let vimdescriptor=systemlist('tmux display-message -p "#S:#I.#P"')[0]
    let descriptorlist=systemlist('tmux list-panes -sF "#S:#I.#P"')
    if len(descriptorlist) == 1
      echo "vim is the only pane!"
      return -1
    else
      for entry in descriptorlist
          if entry == vimdescriptor | continue | endif
          let descriptor=entry
          break
      endfor
    endif
  endif

  let [session, window, pane] = split(descriptor, '\W')
  call tmuxify#pane_set('!', session, window, pane)
  echo "associated with pane " . session . ":" . window . "." . pane
endfunction

function! TxCreateWrapper()
  if tmuxify#get_associated_pane('!') != -1
    echo 'TxCreateWrapper: already associated with a pane'
    return -1
  endif
  if !exists('$TMUX')
    call system('urxvt -e zsh -c "tmux" &')
    let counter = 0
    while counter < 100
      if empty(systemlist('pgrep tmux'))
        let counter += 1
        sleep 20m
      else
        break
      endif
    endwhile
    call AutoAssociate()
  else
    TxCreate!
  endif
endfunction

nnoremap <silent> \a  :call tmuxify#pane_command('!', 'copy-mode')<CR>
nnoremap <silent> \c  :TxSigInt!<CR>
nnoremap <silent> \d  :call tmuxify#pane_send_raw('C-d', '!')<CR>
nnoremap <silent> \j  :<C-u>call TmuxifySendLines(v:count, "j")<CR>
nnoremap <silent> \k  :<C-u>call TmuxifySendLines(v:count, "k")<CR>
nnoremap <silent> \l  :TxClear!<CR>
nnoremap          \o  :call TxCreateWrapper()<CR>
nnoremap <silent> \s  "vyy:TxSend!(@v)<CR>
vnoremap <silent> \s  "vy:TxSend!(@v)<CR>
" TODO - if somebody C-c's or puts invalid input in the prompt, errors aren't handled
nnoremap <silent> \t  :TxSetPane<CR>
nnoremap <silent> \T  :TxSetPane!<CR>
nnoremap <silent> \w  :call tmuxify#pane_send_raw('C-u', '!')<CR>:TxClear!<CR>
nnoremap <silent> \x  :TxKill!<CR>
nnoremap <silent> \|  :TxSend!<CR>
nnoremap <silent> \<CR>  :call tmuxify#pane_send_raw('C-j', '!')<CR>
nnoremap          \\  :call AutoAssociate()<CR>

nnoremap <silent> <up>    :call tmuxify#pane_send_raw('C-u', '!')<CR>
nnoremap <silent> <down>  :call tmuxify#pane_send_raw('C-d', '!')<CR>
nnoremap <silent> <left>  :call tmuxify#pane_send_raw('C-b', '!')<CR>
nnoremap <silent> <right> :call tmuxify#pane_send_raw('C-f', '!')<CR>
" }}}
" neovim terminal maps {{{
if has('nvim')
    tnoremap <Esc> <C-\><C-n>
endif
let g:terminal_scrollback_buffer_size = 100000
" }}}
" }}}
" vim: foldmethod=marker foldlevel=1 foldmarker={{{,}}}
