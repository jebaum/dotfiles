" Initial setup {{{
runtime macros/matchit.vim
let mapleader = ','
augroup LineNumberAutoToggle
  autocmd InsertEnter * let b:relativenumberSetting = &relativenumber | setlocal norelativenumber
  autocmd InsertLeave * if b:relativenumberSetting | setlocal relativenumber | endif
augroup END
" Vim-Plug  {{{
if empty(glob("~/.vim/autoload/plug.vim"))
    silent call mkdir(expand("~/.vim/autoload", 1), 'p')
    execute '!curl -fLo '.expand("~/.vim/autoload/plug.vim", 1).' https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
endif

let g:plug_threads = 50
let @p="03df/IPlug 'A':wV:Source:PlugInstall"

call plug#begin('~/.vim/bundle')
Plug 'gruvbox-community/gruvbox'

if has('unix')
  Plug 'junegunn/gv.vim',    {'on': ['GV']}
  Plug 'tommcdo/vim-fugitive-blame-ext'
  Plug 'tpope/vim-fugitive'
  " Plug 'jebaum/vim-tmuxify'
endif

if has('python') || has('python3') " pip3 install neovim only sets 'python3' to 1
  Plug 'SirVer/ultisnips'
  Plug 'Valloric/MatchTagAlways', {'for': ['html', 'xml']}
  Plug 'honza/vim-snippets'
endif

if has('nvim')
  Plug 'lukas-reineke/indent-blankline.nvim'
  let g:indent_blankline_char = 'â”‚' " TODO map IndentBlanklineToggle?
  let g:indent_blankline_filetype_exclude = ['help', 'startify']
  Plug 'code-biscuits/nvim-biscuits'
  Plug 'glepnir/lspsaga.nvim'
  Plug 'hrsh7th/nvim-compe'
  Plug 'kevinhwang91/nvim-hlslens'
  Plug 'kyazdani42/nvim-tree.lua' " TODO this seems nice, configure it
  Plug 'neovim/nvim-lspconfig'
  Plug 'norcalli/nvim-colorizer.lua'
  Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'}
  " Plug 'kabouzeid/nvim-lspinstall'
  " Plug 'kyazdani42/nvim-web-devicons'
  " Plug 'alec-gibson/nvim-tetris'
else
  Plug 'othree/vim-autocomplpop'
  Plug 'vim-scripts/L9'
endif
" Plug 'luochen1990/rainbow', {'on': ['RainbowToggle', 'RainbowToggleOff', 'RainbowToggleOn']}
" Plug 'TimUntersberger/neogit' " still WIP. fugitive better for now
" Plug 'nvim-lua/plenary.nvim' " required by neogit, possibly other lua plugins
" https://github.com/RRethy/vim-illuminate " alternative to brightest that can use LSP
" Plug 'liuchengxu/vim-which-key' " cool and useful, set this up sometime
Plug 'Konfekt/FastFold'
Plug 'Valloric/ListToggle'
Plug 'airblade/vim-rooter'
Plug 'christoomey/vim-tmux-navigator'
Plug 'farmergreg/vim-lastplace' " much simpler version of vim-stay
Plug 'haya14busa/vim-asterisk'
Plug 'hoob3rt/lualine.nvim'
Plug 'junegunn/fzf'
Plug 'junegunn/fzf.vim'
Plug 'junegunn/vim-easy-align'
Plug 'justinmk/vim-sneak'
Plug 'mhinz/vim-signify' " do not lazy load. maybe https://github.com/lewis6991/gitsigns.nvim ?
Plug 'mhinz/vim-startify'
Plug 'osyo-manga/vim-brightest', {'on': ['BrighestClear', 'BrightestEnable', 'BrightestDiable', 'BrightestHighlight', 'BrightestLock', 'BrightestUnlock', 'BrightestToggle']}
Plug 'preservim/nerdcommenter'
Plug 'talek/obvious-resize', {'on': ['ObviousResizeLeft', 'ObviousResizeDown', 'ObviousResizeUp', 'ObviousResizeRight']}
Plug 'tommcdo/vim-exchange'
Plug 'tpope/vim-eunuch', {'on': ['Unlink', 'Remove', 'Move', 'Rename', 'Chmod', 'Mkdir', 'Find', 'Locate', 'SudoEdit', 'SudoWrite', 'Wall', 'W']}
Plug 'tpope/vim-jdaddy'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-sleuth' " auto detect indent settings
Plug 'tpope/vim-surround' " TODO vim-sandwich? https://github.com/machakann/vim-sandwich/wiki/Introduce-vim-surround-keymappings
Plug 'tpope/vim-unimpaired'
Plug 'vim-pandoc/vim-pandoc-syntax', {'for': 'pandoc'}
Plug 'vim-scripts/SyntaxRange', {'for': ['markdown', 'pandoc']}
Plug 'vim-utils/vim-husk'
Plug 'wellle/targets.vim' " https://github.com/wellle/targets.vim/issues/225, and issues/247 - some issues with folds
Plug 'wellle/tmux-complete.vim'
Plug 'wsdjeg/vim-fetch'
call plug#end()
" }}}
" gruvbox + colorizer {{{
set termguicolors " must be set before colorizer.setup()
lua require'colorizer'.setup()
let g:gruvbox_invert_selection=0
set background=dark
colorscheme gruvbox
function! TweakColors() " override some defaults
  highlight Comment       gui=italic
  highlight Folded                     ctermbg=16                  guibg=#000000
  highlight Function      ctermfg=43                guifg=#00D7AF
  highlight IncSearch     ctermfg=250  ctermbg=24   guifg=#552583  guibg=#FDB927 gui=bold
  highlight JustYanked    ctermfg=108  ctermbg=235  guifg=#F0F0F0  guibg=#552583
  highlight MatchParen    ctermfg=16   ctermbg=201  guifg=#000000  guibg=#FF00FF
  highlight Normal        ctermfg=223               guifg=#FFD7AF  guibg=#1C1C1C
  highlight QuickFixLine               ctermbg=16                  guibg=#000000
  highlight Search        ctermfg=250  ctermbg=24   guifg=#552583  guibg=#FDB927
  highlight SpecialKey    ctermfg=231  ctermbg=236  guifg=#FFFFFF  guibg=#303030
  highlight String        ctermfg=46                guifg=#70F0F0
  highlight Pmenu         guifg=#EBDBB2  guibg=#282828
  highlight PmenuSel      guifg=#FDB927  guibg=#552583 cterm=bold gui=bold
  highlight HlSearchLensNear guifg=#DDDDDD guibg=#000000 gui=italic
  highlight HlSearchLens     guifg=#999999 guibg=#202020 gui=italic
  highlight BiscuitColor      guifg=#999999 guibg=#101010 gui=italic

  " highlight LspReferenceRead  ctermfg=250  ctermbg=24   guifg=#552583  guibg=#FDB927
  " highlight LspReferenceText  ctermfg=250  ctermbg=24   guifg=#552583  guibg=#FDB927
  " highlight LspReferenceWrite ctermfg=250  ctermbg=24   guifg=#552583  guibg=#FDB927

  " TODO update normal diff highlights so gdiffsplit isn't awful
  " highlight NeogitDiffAdd  gui=none guifg=#CCCCCC guibg=#132E1F
  " highlight NeogitDiffAddHighlight gui=none guifg=#FFFFFF guibg=#226D32
  " highlight NeogitDiffDelete gui=none guifg=#CCCCCC guibg=#36181c
  " highlight NeogitDiffDeleteHighlight gui=none guifg=#FFFFFF guibg=#882727
  " highlight NeogitHunkHeader gui=none guifg=#FFFFFF guibg=#552583
  " highlight NeogitHunkHeaderHighlight  gui=none guifg=#000000 guibg=#FDB927
  " highlight NeogitDiffContextHighlight gui=none guifg=#C0C0C0 guibg=#000000
endfunction
augroup TweakColors
  autocmd!
  autocmd VimEnter * call TweakColors()
augroup END
" }}}
" }}}
" Misc {{{
" Command mode maps and abbreviations {{{
" use one of these maps in the middle of a search to move, copy, or delete text
cnoremap $t <CR>:t''<CR>
cnoremap $T <CR>:''t.<CR>
cnoremap $m <CR>:m''<CR>
cnoremap $M <CR>:''m.<CR>
cnoremap $d <CR>:d<CR>``
" }}}
" FileType autocmds {{{
augroup FileTypeSettings
  autocmd!
  autocmd BufRead *vimrc* nnoremap <buffer> z<Space> zMzrzvzz
  autocmd FileType gitcommit setlocal nocursorline nocursorcolumn
  autocmd FileType make setlocal noexpandtab shiftwidth=4 tabstop=4
  autocmd FileType vim syn keyword vimCommand Plug
  autocmd BufNewFile,BufRead *.log  setlocal filetype=log
  autocmd BufNewFile,BufFilePre,BufRead *.md setlocal filetype=markdown.pandoc " from vim-pandoc-syntax
  autocmd BufReadPost,BufNewFile *.vue setlocal filetype=vue
augroup END
" }}}
" align quickfix output {{{
augroup QuickfixAlign
  autocmd!
  autocmd BufRead quickfix setl modifiable
            \| silent exe "%!perl -ple '
                \my ($file, $pos, $msg) = split qr{[|]}, $_, 3;
                \my $aligned_pos = sub {
                \  my @p = split qr{[ ]}, shift;
                \  return                                        if @p == 0;
                \  return sprintf q{\\%3s}, @p                   if @p == 1;
                \  return sprintf q{\\%3s \\%s}, @p              if @p == 2;
                \  return sprintf q{\\%3s \\%s \\%2s}, @p        if @p == 3;
                \  return sprintf q{\\%3s \\%s \\%2s \\%-8s}, @p if @p == 4;
                \  return join q{ }, @p;
                \}->($pos);
                \$_ = join q{|}, $file, $aligned_pos, $msg;
            \'"
            \| setl nomodifiable
augroup END
" }}}
" generate map for alt and <C-Space> in both vim and gvim {{{
function! Altmap(char)
  if has('gui_running') || has('nvim') | return '<A-'.a:char.'>' | else | return '<Esc>'.a:char|endif
endfunction
function! AltShiftmap(char)
  if has('gui_running') || has('nvim') | return '<A-S-'.a:char.'>' | else | return '<Esc>'.a:char|endif
endfunction
let g:ctrl_space = has("gui_running") ? "<C-Space>" : "<C-@>"
" }}}
" autocmd to highlight yanked text {{{
augroup HighlightYankedText
    autocmd!
    autocmd TextYankPost * silent! lua vim.highlight.on_yank{higroup="JustYanked", timeout=750}
augroup END
" }}}
" }}}
" Functions {{{
" StripWhitespace function {{{
function! StripWhitespace(line1, line2)
    let _s=@/
    let l = line(".")
    let c = col(".")
    execute ':' . a:line1 . ',' . a:line2 . 's/\s\+$//e'
    let @/=_s
    call cursor(l, c)
endfunction
command! -range=% Strip call StripWhitespace(<line1>, <line2>)
" }}}
" Visual mode increment function {{{
function! Increment()
  let a = line('.') - line("'<")
  let c = virtcol("'<")
  if a > 0
    execute 'normal! '.c.'|'.a."\<C-a>"
  endif
  normal `<
endfunction
" }}}
" ProcessJSON {{{
function! ProcessJSON()
    %s/\s\+$//e  " strip trailing whitespace
    g/^$/d       " delete empty lines
    %join        " join whole file into one line
    %s/^\s\+//e  " strip any leading whitespace from opening line
    call Stab(2) " set tabstop to 2
    call jdaddy#reformat('jdaddy#outer_pos', 0) " tpope jdaddy
endfunction
command! JSON call ProcessJSON()
" }}}
" Source that accepts range {{{
function! DetectIfInVimFunction(...)
  " search upward from the current line for the command 'function' to see if we're currently in a function
  " if we find 'endfunction' command before we find 'function', we aren't in a function
  " if we find 'function' first, then search downward for the corresponding 'endfunction'
  " return list of function start and end line numbers if successful, list of -1 if not

  " TODO use search() ? `call search('function!', 'b')'
  let startline   = line('.')
  let currentline = line('.')

  if a:0 != 0
    let iterlimit = a:1
  else
    let iterlimit = 250
  endif

  let i = 0
  while i < iterlimit

    " see if the text 'function' or 'endfunction' is on the current line
    let funmatchpos    = match(getline(currentline), "function!")
    let endfunmatchpos = match(getline(currentline), "endfunction")

    if funmatchpos != -1  " we found the text 'function'
      let funsynlist = map(synstack(currentline, funmatchpos + 1),'synIDattr(v:val,"name")')
      if index(funsynlist, 'vimFuncKey') >= 0 " function start markers are in the VimFuncKey syntax group
        " save the line number of the first line of the function, and reset the search position
        let startfunline = currentline
        let currentline  = startline
      endif
    endif

    if endfunmatchpos != -1 " we found the text 'endfunction'
      let endfunsynlist = map(synstack(currentline, endfunmatchpos + 1),'synIDattr(v:val,"name")')
      if index(endfunsynlist, 'vimCommand') >= 0 " endfunction markers are in the VimCommand syntax group
        if currentline == startline || exists('startfunline')
          " if we started out with the cursor on endfunction, or we've already found a function start
          let endfunline = currentline
        else " we found an endfunction before finding a function start, so we aren't currently in a function
          break
        endif
      endif
    endif

    let i += 1

    if exists('startfunline') && exists('endfunline')
      return [startfunline, endfunline]
    elseif exists('startfunline')
      " we found the function start, so now we want to search downward
      let currentline += 1
    else
      let currentline -= 1
    endif
  endwhile
  return [-1, -1]
endfunction

function! SourcePart(line1, line2)
   let tmp = @z
   silent exec a:line1.",".a:line2."yank z"
   let @z = substitute(@z, '\n\s*\\', '', 'g')
   @z
   let @z = tmp
endfunction

function! SourceCurrentFunction()
  let [startfunline, endfunline] = DetectIfInVimFunction()
  if startfunline != -1
    call SourcePart(startfunline, endfunline)
    echo 'sourced ' . strpart(getline(startfunline), strlen('function! '))
  else
    echo 'cursor is not in a function'
  endif
endfunction

" if some argument is given, this command calls built-in command :source with
" given arguments; otherwise calls function SourcePart() which sources
" visually selected lines of the buffer.
command! -nargs=? -bar -range Source if empty("<args>") | call SourcePart(<line1>, <line2>) | else | exec "so <args>" | endif
" }}}
" Auto open certain buf and file types in vertical split if there's room {{{
let g:autosplit_ft = ['man', 'fugitive', 'gitcommit']
let g:autosplit_bt = ['help']

function! NewSplit()
  if (index(get(g:, 'autosplit_bt', []), &buftype) != -1 ||
    \ index(get(g:, 'autosplit_ft', []), &filetype) != -1)
    let b = bufnr()
    let p = winnr('#')
    let v = winwidth(p) >= getwinvar(p, '&tw', 80) + getwinvar(winnr(), '&tw', 80)
    wincmd J
    wincmd p
    if v
      vsplit
      vertical resize 80
    else
      split
    endif
    exe b . 'b'
    exe winnr('50j') . 'wincmd q'
  endif
endfun

augroup Autosplit
  autocmd!
  autocmd WinNew * autocmd BufEnter * ++once call NewSplit()
augroup END
" }}}
" ColumnFlash {{{
let g:colorList = ['#3E2D10', '#7D5A14', '#BC871E', '#FAB428', '#FDB927', '#FDB927', '#FDB927', '#FDB927']
let g:sleepCommand = 'sleep ' . string(400 / len(g:colorList)) . 'm'
function! ColumnFlash()
    let hadCursorline=&cursorline
    setlocal cursorline cursorcolumn
    for i in range (0, len(g:colorList) - 1)
        execute 'highlight CursorLine guibg=' . g:colorList[i]
        redraw
        if getchar(1) != 0
            break
        endif
        execute g:sleepCommand
    endfor
    execute 'highlight CursorLine guibg=#3C3836'
    if !hadCursorline | setlocal nocursorline | endif
    setlocal nocursorcolumn
endfunction
" }}}
" }}}
" Plugins {{{
" biscuits {{{
lua << EOF
require('nvim-biscuits').setup({
  default_config = {
    max_length = 60,
    min_distance = 15,
    prefix_string = " ï£¡ "
  },
  on_events = { 'InsertLeave', 'CursorHoldI' }
})
EOF
" }}}
" brightest {{{
let g:brightest_enable = 0
let g:brightest#highlight = { 'group': 'BrightestCustom' }
highlight BrightestCustom ctermfg=250  ctermbg=24   guifg=#552583  guibg=#FDB927
" }}}
" compe {{{
set completeopt=menuone,noselect
let g:compe = {}
let g:compe.enabled = v:true
let g:compe.autocomplete = v:true " TODO may need to set this to false in some slow files like typescript and vue
let g:compe.debug = v:false
let g:compe.min_length = 2 " default is 1
let g:compe.preselect = 'enable'
let g:compe.throttle_time = 80
let g:compe.source_timeout = 200
let g:compe.resolve_timeout = 800
let g:compe.incomplete_delay = 400
let g:compe.max_abbr_width = 100
let g:compe.max_kind_width = 100
let g:compe.max_menu_width = 100
let g:compe.documentation = v:true

let g:compe.source = {}
let g:compe.source.buffer = v:true
let g:compe.source.calc = v:true
let g:compe.source.emoji = v:false
let g:compe.source.nvim_lsp = v:true
let g:compe.source.nvim_lua = v:false
let g:compe.source.path = v:true
let g:compe.source.spell = v:true
let g:compe.source.tmux = v:true " integration with tmux-complete
let g:compe.source.ultisnips = v:true

" https://github.com/hrsh7th/nvim-compe/issues/159#issuecomment-775947348
command! CompeEnable  let g:compe.autocomplete = v:true  | call compe#setup(g:compe)
command! CompeDisable let g:compe.autocomplete = v:false | call compe#setup(g:compe)

inoremap <silent><expr> <C-Space> compe#complete()
inoremap <silent><expr> <CR>      compe#confirm('<CR>')
inoremap <silent><expr> <C-e>     compe#close('<C-e>')
inoremap <silent><expr> <C-f>     compe#scroll({ 'delta': +4 })
inoremap <silent><expr> <C-d>     compe#scroll({ 'delta': -4 })
" }}}
" easy-align {{{
xmap ga <Plug>(EasyAlign)
nmap ga <Plug>(EasyAlign)
" }}}
" fugitive {{{
autocmd User fugitive  " .. to go back up to parent directory when browsing git tree
  \ if fugitive#buffer().type() =~# '^\%(tree\|blob\)$' |
  \   nnoremap <buffer> .. :edit %:h<CR> |
  \ endif
autocmd BufReadPost fugitive://* set bufhidden=delete  " stop fugitive from making tons of buffers
" }}}
" fzf {{{
function! GetBufferUrls()
  redir => bufferurls
  silent execute 'write !xurls'
  redir END
  return split(bufferurls)
endfunction

function! HandleUrl(urls)
  if empty(systemlist('pgrep firefox')) " firefox isn't running, start it
    silent! execute "!firefox &"
    " without sleep, race between firefox starting and below command with --new-tab being run may result in multiple windows opening
    sleep 500m " could replace this with a timer/jobstart callback thing, but this is one simple line that works perfectly in practice
  endif

  let argstring = join(map(a:urls, { idx, val -> "--new-tab '" . fnameescape(val) . "'" }))
  silent! execute "!firefox " . argstring . " &"
endfunction

" FZF Buffer Delete
function! s:list_buffers()
  redir => list
  silent ls
  redir END
  return split(list, "\n")
endfunction

function! s:delete_buffers(lines)
  execute 'bwipeout' join(map(a:lines, {_, line -> split(line)[0]}))
endfunction

command! FZFBD call fzf#run(fzf#wrap({
  \ 'source': s:list_buffers(),
  \ 'sink*': { lines -> s:delete_buffers(lines) },
  \ 'options': '--multi --reverse --bind ctrl-a:select-all+accept'
\ }))


let g:fzf_buffers_jump = 1 " jump to the existing window if possible
command! -bang -nargs=* FZFFindCache call fzf#run(fzf#wrap({'source': 'cat '.expand('~/.cache/allfiles.txt'), 'options': ['--preview', '~/.vim/bundle/fzf.vim/bin/preview.sh {}', '--multi', '--prompt', 'findcache > ']}))
command! -bang -nargs=* FZFUrls call fzf#run(fzf#wrap({'sink*': function('HandleUrl'), 'source': GetBufferUrls(), 'options': ['--multi', '--prompt', 'urls > ']}))
unlet! g:fzf_colors " makes fzf.vim use the 24 bit colors configured in env variables https://github.com/junegunn/fzf.vim/issues/1152
if has('nvim') && !exists('g:fzf_layout')
  autocmd! FileType fzf
  autocmd  FileType fzf set laststatus=0 noshowmode noruler
        \| autocmd BufLeave <buffer> set laststatus=2 showmode ruler
endif
" }}}
" hlslens + vim-asterisk {{{
lua << EOF
require('hlslens').setup({
    calm_down = true,
})
EOF
noremap <silent> n <Cmd>execute('normal! ' . v:count1 . 'n')<CR><Cmd>silent! foldopen!<CR>
            \<Cmd>lua require('hlslens').start()<CR>
noremap <silent> N <Cmd>execute('normal! ' . v:count1 . 'N')<CR><Cmd>silent! foldopen!<CR>
            \<Cmd>lua require('hlslens').start()<CR>
map *  <Plug>(asterisk-z*)<Cmd>lua require('hlslens').start()<CR>
map #  <Plug>(asterisk-z#)<Cmd>lua require('hlslens').start()<CR>
map g* <Plug>(asterisk-gz*)<Cmd>lua require('hlslens').start()<CR>
map g# <Plug>(asterisk-gz#)<Cmd>lua require('hlslens').start()<CR>
let g:asterisk#keeppos = 1
" }}}
" listtoggle {{{
let g:lt_quickfix_list_toggle_map = '<leader>e'
let g:lt_location_list_toggle_map = '<leader>l'
" }}}
" lspconfig {{{
lua << EOF
-- see neovim/lspconfig repo for documentation on config details + language server initialization below
local saga = require('lspsaga')
saga.init_lsp_saga()

local nvim_lsp = require('lspconfig')
local on_attach = function(client, bufnr)
  print("LSP started.");
  local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end
  local function buf_set_option(...) vim.api.nvim_buf_set_option(bufnr, ...) end

  buf_set_option('omnifunc', 'v:lua.vim.lsp.omnifunc')

  -- Mappings.
  local opts = { noremap=true, silent=true }
  buf_set_keymap('n', '\\a', '<cmd>lua vim.lsp.buf.code_action()<CR>', opts)
  buf_set_keymap('n', '\\d', '<Cmd>lua vim.lsp.buf.definition()<CR>', opts)
  buf_set_keymap('n', '\\D', '<Cmd>lua vim.lsp.buf.declaration()<CR>', opts)
  buf_set_keymap('n', '\\h', '<Cmd>lua vim.lsp.buf.hover()<CR>', opts)
  buf_set_keymap('n', '\\i', '<cmd>lua vim.lsp.buf.implementation()<CR>', opts)
  buf_set_keymap('n', '\\l', '<cmd>lua vim.lsp.diagnostic.show_line_diagnostics()<CR>', opts)
  buf_set_keymap('n', '\\L', '<cmd>lua vim.lsp.diagnostic.set_loclist()<CR>', opts)
  buf_set_keymap('n', '\\r', '<cmd>lua vim.lsp.buf.references()<CR>', opts)
  buf_set_keymap('n', '\\R', '<cmd>lua vim.lsp.buf.rename()<CR>', opts)
  buf_set_keymap('n', '\\td', '<cmd>lua vim.lsp.buf.type_definition()<CR>', opts)
  buf_set_keymap('n', '[d', '<cmd>lua vim.lsp.diagnostic.goto_prev()<CR>', opts)
  buf_set_keymap('n', ']d', '<cmd>lua vim.lsp.diagnostic.goto_next()<CR>', opts)

  -- Set some keybinds conditional on server capabilities
  if client.resolved_capabilities.document_formatting then
    buf_set_keymap("n", "\\f", "<cmd>lua vim.lsp.buf.formatting()<CR>", opts)
  end
  if client.resolved_capabilities.document_range_formatting then
    buf_set_keymap("v", "\\f", "<cmd>lua vim.lsp.buf.range_formatting()<CR>", opts)
  end

  -- Set autocommands conditional on server_capabilities
  if false and client.resolved_capabilities.document_highlight then -- TODO currently disabled, but good alternative to brightest here where supported
    vim.api.nvim_exec([[
      augroup lsp_document_highlight
        autocmd! * <buffer>
        autocmd CursorHold <buffer> lua vim.lsp.buf.document_highlight()
        autocmd CursorMoved <buffer> lua vim.lsp.buf.clear_references()
      augroup END
    ]], false)
  end
end

-- Use a loop to conveniently both setup defined servers
-- and map buffer local keybindings when the language server attaches
-- NOTE: need to install these manually or use one of the lspinstall plugins
local servers = { "tsserver", "vimls", "bashls", "vuels" }
for _, lsp in ipairs(servers) do
  nvim_lsp[lsp].setup {
    on_attach = on_attach,
    settings = {
      vetur = {
        ignoreProjectWarning = true
      }
    }
  }
end
EOF
" }}}
" lualine {{{
" https://got-ravings.blogspot.com/2008/10/vim-pr0n-statusline-whitespace-flags.html
let b:tabwarning = ''
let b:trailingspacewarning = ''
function! TreesitterStatusline()
  let l:ts = nvim_treesitter#statusline(90)
  return l:ts == v:null ? '' : l:ts
endfunction
function! StatuslineTabWarning()
    if stridx(mode(), 'i') != -1 | return b:tabwarning | endif " don't run while in insert mode
    let tabs = search('^\t', 'nw') != 0
    let spaces = search('^ ', 'nw') != 0

    if tabs && spaces
        let b:tabwarning = '[mixed-indenting]'
    elseif (spaces && !&et) || (tabs && &et) " expandtab setting doesn't match buffer contents
        let b:tabwarning = '[&et]'
    else
        let b:tabwarning = ''
    endif
    return b:tabwarning
endfunction

function! StatuslineTrailingSpaceWarning()
  if stridx(mode(), 'i') != -1 | return b:trailingspacewarning | endif " don't run while in insert mode
    let trailingSpaces = search('\s\+$', 'nw')
    if trailingSpaces != 0
        let b:trailingspacewarning = '[\s ' . trailingSpaces . ']'
    else
        let b:trailingspacewarning = ''
    endif
    return b:trailingspacewarning
endfunction
if has('nvim')
lua << EOF
-- lualine.section_separators = {'î‚´', 'î‚¶'}
-- lualine.component_separators = {'î‚µ', 'î‚·'}
require'lualine'.setup  {
    options = {
      theme = 'onedark',
      component_separators = {'î‚±', 'î‚³'},
      section_separators = {'î‚°', 'î‚²'},
    },
    sections = {
      lualine_b = { {'branch', icon = 'î‚ '}, 'diff' },
      lualine_c = { {'filename', path = 1}, 'TreesitterStatusline' },
      lualine_z = { {'StatuslineTabWarning', color = {fg = '#ffffff', bg = '#ff0000'}}, 'StatuslineTrailingSpaceWarning', 'location' },
    },
    inactive_sections = {
      lualine_c = { {'filename', path = 1} },
    }
}
EOF
endif
" }}}
" match tag {{{
let g:mta_filetypes = {
    \ 'html' : 1,
    \ 'xhtml' : 1,
    \ 'xml' : 1,
    \ 'jinja' : 1,
    \ 'php' : 1,
    \}
" }}}
" neogit {{{
" lua << EOF
" local neogit = require('neogit')
" neogit.setup {
  " signs = { -- { CLOSED, OPENED }
    " hunk = { ">", "v" },
  " }
" }
" EOF
" }}}
" nerdcommenter {{{
let g:NERDSpaceDelims            = 1
let g:NERDCompactSexyComs        = 0
let g:NERDCommentEmptyLines      = 1
let g:NERDTrimTrailingWhitespace = 1
" }}}
" netrw {{{
let g:netrw_bufsettings = 'noma nomod nu nobl nowrap ro'
" }}}
" pandoc {{{
augroup PandocMaps
  autocmd!
  autocmd filetype pandoc nnoremap <buffer><silent><expr> gc ":set cole=" . (&cole != 0 ? "0" : "2") . "<CR>"
augroup END
" let g:pandoc#syntax#codeblocks#embeds#langs = ["ruby", "c"]  " achieve same affect as SyntaxRange
let g:pandoc#folding#level = 1
let g:pandoc#formatting#textwidth = 80
let g:pandoc#folding#fdc = 0 " foldcolumn width
let g:pandoc#modules#disabled = ["folding"]
let g:pandoc#after#modules#enabled = ["ultisnips", "unite"]
" }}}
" signify {{{
let g:signify_disable_by_default = 0
let g:signify_vcs_list           = [ 'git' ]
let g:signify_sign_change        = '~'
let g:signify_sign_show_count    = 1
nmap ]c <Plug>(signify-next-hunk)
nmap [c <Plug>(signify-prev-hunk)

" directly pulled from signify docs

augroup ShowHunkNumbers
  autocmd User SignifyHunk call s:show_current_hunk()
  function! s:show_current_hunk() abort
    let h = sy#util#get_hunk_stats()
    if !empty(h)
      echo printf('[Hunk %d/%d]', h.current_hunk, h.total_hunks)
    endif
  endfunction
augroup END
" }}}
" sneak  {{{
let g:sneak#label = 0
let g:sneak#use_ic_scs = 1
let g:sneak#absolute_dir = 1
map f <Plug>Sneak_f
map F <Plug>Sneak_F
map t <Plug>Sneak_t
map T <Plug>Sneak_T
map <M-;> <Plug>Sneak_,
omap z <Plug>Sneak_s
omap Z <Plug>Sneak_S
" }}}
" startify {{{
let g:rooter_silent_chdir = 1 " sticking this here because i'm lazy
let g:startify_lists = [
      \ { 'type': 'bookmarks', 'header': ['   Bookmarks']      },
      \ { 'type': 'files',     'header': ['   MRU Global']     },
      \ { 'type': 'dir',       'header': ['   MRU '. getcwd()] },
      \ { 'type': 'sessions',  'header': ['   Sessions']       },
      \ ]
let g:startify_bookmarks          = [ '~/dotfiles/vim/vimrc', '~/Dropbox/todo/TODO.txt' ]
let g:startify_files_number       = 10
let g:startify_session_detection  = 1 " show session when Session.vim is found in current directory
let g:startify_session_autoload   = 0 " opening directories with a Session.vim will have it auto load
let g:startify_custom_indices     = ['a','f','h','j','k','l','w','r','u','o','p','z','x','n','m']
if has('nvim')
  let g:startify_custom_header     = [
    \ '    /\\\\\     /\\\  /\\\        /\\\  /\\\\\\\\\\\  /\\\\            /\\\\       ',
    \ '    \/\\\\\\   \/\\\ \/\\\       \/\\\ \/////\\\///  \/\\\\\\        /\\\\\\      ',
    \ '     \/\\\/\\\  \/\\\ \//\\\      /\\\      \/\\\     \/\\\//\\\    /\\\//\\\     ',
    \ '      \/\\\//\\\ \/\\\  \//\\\    /\\\       \/\\\     \/\\\\///\\\/\\\/ \/\\\    ',
    \ '       \/\\\\//\\\\/\\\   \//\\\  /\\\        \/\\\     \/\\\  \///\\\/   \/\\\   ',
    \ '        \/\\\ \//\\\/\\\    \//\\\/\\\         \/\\\     \/\\\    \///     \/\\\  ',
    \ '         \/\\\  \//\\\\\\     \//\\\\\          \/\\\     \/\\\             \/\\\ ',
    \ '          \/\\\   \//\\\\\      \//\\\        /\\\\\\\\\\\ \/\\\             \/\\\',
    \ '           \///     \/////        \///        \///////////  \///              \///',
    \ '',
    \ '',
    \ ]
else
  let g:startify_custom_header     = [
    \ '    /\\\        /\\\   /\\\\\\\\\\\   /\\\\            /\\\\  ',
    \ '    \/\\\       \/\\\  \/////\\\///   \/\\\\\\        /\\\\\\  ',
    \ '     \//\\\      /\\\       \/\\\      \/\\\//\\\    /\\\//\\\  ',
    \ '       \//\\\    /\\\        \/\\\      \/\\\\///\\\/\\\/ \/\\\  ',
    \ '         \//\\\  /\\\         \/\\\      \/\\\  \///\\\/   \/\\\  ',
    \ '           \//\\\/\\\          \/\\\      \/\\\    \///     \/\\\  ',
    \ '             \//\\\\\           \/\\\      \/\\\             \/\\\  ',
    \ '               \//\\\         /\\\\\\\\\\\  \/\\\             \/\\\  ',
    \ '                 \///         \///////////   \///              \///   ',
    \ '',
    \ '',
    \ ]
endif
" }}}
" treesitter {{{
" https://git.sr.ht/~seirdy/dotfiles/tree/master/.config/nvim/init.vim
if has('nvim')
lua << EOF
require'nvim-treesitter.configs'.setup {
  ensure_installed = "maintained", -- one of "all", "maintained" (parsers with maintainers), or a list of languages
  highlight = {
    enable = true,              -- false will disable the whole extension
    disable = { "clojure", "rust" },  -- list of language that will be disabled
  },
  indent = {
    enable = true
  },
}
EOF
endif
" }}}
" ultisnips {{{
let g:UltiSnipsExpandTrigger       = "<C-l>"
let g:UltiSnipsJumpForwardTrigger  = "<C-l>"
let g:UltiSnipsJumpBackwardTrigger = "<C-h>"
let g:UltiSnipsListSnippets        = "<C-f>"
let g:snips_author                 = 'James Baumgarten'
" }}}
" }}}
" General {{{
" Set options {{{
set number                     " show line numbers
set relativenumber             " use relative line numbers
set signcolumn=auto            " merge signcolumn with line number
set exrc                       " allow directory specific .vimrc files
set secure                     " prevent directory specific .vimrcs from doing malicious things
set nolazyredraw               " redraw the screen while executing macros. required for search count to display on my setup
set clipboard+=unnamedplus     " by default, * system clipboard
set titlestring=%<%q%F%h%r%m   " file name
set title titlelen=150         " max length of title string
set backspace=indent,eol,start " allow backspace in insert mode
set autoread                   " reload files changed outside of vim
set splitbelow                 " splits open below
set splitright                 " vsplits open on right
set hidden                     " allows navigating away from buffers with unsaved changes
set fillchars=""               " no dashes in folds or vertical bars in vsplits
set noruler                    " don't show the ruler
set laststatus=2               " always display the statusline
set history=10000              " length of command history
set showmode                   " show what mode we're in on the bottom line
set showcmd                    " show current command or visual selection info in bottom line
set cmdwinheight=10            " height of command line window
set showmatch                  " don't flash to matching paren when typing
set matchtime=3                " tenths of a second to flash to matching paren
set incsearch                  " find as you type
set hlsearch                   " hilight search terms
set magic                      " change how backslashes are handled in searches
set ignorecase                 " case insensitive search by default
set fileignorecase             " ignore case in commands like :buffer
set smartcase                  " case sensitive search if search contains uppercase letter
set nostartofline              " don't reset cursor to start of line when moving around
set nrformats=hex              " for C-a and C-x. recognize '0x' prefix as hex
set scrolljump=1               " lines to scroll when cursor leaves screen
set scrolloff=1                " start scrolling when 8 lines away from margins
set sidescrolloff=5            " keep 5 columns next to the cursor when scrolling horizontally
set updatetime=400             " swap file writes and CursorHold autocmd. weird fold closing problem
set encoding=utf-8             " new files use utf-8 encoding by default
set ffs=unix,dos,mac           " new files use unix line endings by default
set shortmess+=c               " don't give |ins-completion-menu| messages. helps with completion flicker
set timeout
set timeoutlen=3000
set ttimeoutlen=100
if !has('nvim')
  set restorescreen=on         " restore screen contents on exit
  set ttyfast                  " redraw screen faster
  set cryptmethod=blowfish     " more secure encryption for vim -x
  set esckeys                  " make numpad work
else
  if exists('&inccommand')
    set inccommand=split
  endif
endif
set switchbuf=usetab           " look to see if buffer is already open in another window or tab
set formatoptions-=r           " don't continue comment when hitting enter in insert mode
set formatoptions-=o           " don't automatically continue comment when hitting o in normal mode
set guioptions-=m              " hide gui menu bar
set guioptions-=T              " hide gui toolbar
set guioptions-=r              " hide gui righthand scrollbar
set guioptions-=e              " use regular tabline
set guioptions-=L              " no left scrollbar
set virtualedit=block          " allow visual block mode to move to where there aren't actually characters
set noswapfile                 " seriously who needs them
set tags=./.tags;              " search for .tags file upward (:h file-searching)
set previewheight=20
set viewoptions=cursor,folds,slash,unix " vim-stay configuration
set cursorline
set mouse=                     " disable mouse
set listchars=tab:â–¶-,trail:â€¢,extends:>,eol:Â¬
set dictionary=/usr/share/dict/words  " dictionary completion with <C-X><C-K>
set suffixesadd+=.py,.rb       " suffixes to attempt to use for gf command
set path+=./**
set shell=zsh
set modeline                   " debian.vim defaults in ubuntu 12.04 unset this
if v:version > 703 || v:version == 703 && has("patch541")
  set formatoptions+=j  " delete comment character when joining commented lines
endif
set nojoinspaces        " use only one space after a period when joining lines
syntax sync minlines=2         " speed up syntax hilighting
syntax sync maxlines=5         " speed up syntax hilighting
set synmaxcol=200
set regexpengine=1 " XXX testing to see if this feels faster, some github issues/stackoverflow comments indicated so
let g:no_ocaml_maps = 1
if executable('rg')
    set grepprg=rg\ --vimgrep
    set grepformat=%f:%l:%c:%m
elseif executable('ag')
  set grepprg=ag\ --vimgrep
  set grepformat=%f:%l:%c:%m,%f:%l:%m
endif
filetype plugin indent on
set guicursor=n-v:block,i-c-ci:block " change ver30 to 'block' to get block cursor back during insert mode
" }}}
" Fold {{{
" zf#j manually folds # lines, or zf in visual mode selection.
set foldnestmax =1   " folds only one level deep
set foldmethod  =manual
set foldlevel   =1
" }}}
" Tab/Indent {{{
" https://gist.github.com/LunarLambda/4c444238fb364509b72cfb891979f1dd
set expandtab
set tabstop=4       " Optional, if you want files with tabs to look the same too.
set shiftwidth=4
set softtabstop=-1  " Use value of shiftwidth
set smarttab        " Always use shiftwidth
set autoindent      " auto indent line to match above line when hitting enter
set linebreak       " wrap lines at nice points
set textwidth=0     " disables textwidth

" Set tabstop, softtabstop and shiftwidth to the same value
command! -nargs=* Stab call Stab()
function! Stab(...)
  if a:0 == 1
    let l:tabstop = 1 * a:1
  else
    let l:tabstop = 1 * input('set tabstop = softtabstop = shiftwidth = ')
  endif
  if l:tabstop > 0
    let &l:sts = l:tabstop
    let &l:ts = l:tabstop
    let &l:sw = l:tabstop
  endif
  echomsg
  call SummarizeTabs()
endfunction
" cnoreabbrev stab Stab

function! SummarizeTabs()
  try
    echohl ModeMsg
    echon 'tabstop='.&l:ts
    echon ' shiftwidth='.&l:sw
    echon ' softtabstop='.&l:sts
    if &l:et
      echon ' expandtab'
    else
      echon ' noexpandtab'
    endif
  finally
    echohl None
  endtry
endfunction
" }}}
" Wildmenu {{{
if has("wildmenu")
  set wildmenu                    " turn on wildmenu
  set wildignorecase              " wildmenu doesn't care about case
  set wildmode=longest:full,full
  set wildignore=*.o,*.a,*~,*.pyc " ignore compiled files
  set wildignore+=*.bmp,*.gif,*.ico,*.jpg,*.jpeg,*.mp4,*.mkv,*.avi,*.pdf,*.png,*.mp3
  set wildignore+=*.m4v,*.flv,*.flac,*.wma,*.doc,*.docx,*.ppt,*.pptx,*.m4a,*.m2ts,*.m3u
  set wildignore+=*:2\\,S,*:2\\,RS,*:2\\,FS,*:2\\,,*:2\\,FRS " for mutt
  set wildignore+=.DS_Store,.git,.hg,.svn
  set wildignore+=*~,*.swp,*.tmp
endif
" }}}
" }}}
" Keymaps {{{
" Misc {{{
" misc g maps
nnoremap    gp    gw{gw}
nnoremap    gs    gnv
nnoremap    g;    g;zz
nnoremap    g,    g,zz

" make K do the opposite of J: split lines under the cursor
nnoremap K i<CR><Esc>k$

" line yanks Y yl yaa
nnoremap Y y$
nnoremap yl :let c=col(".")<CR>$v^y:call cursor(line("."),c)<CR>
nnoremap yaa :let c=col(".") <BAR> let l = line(".")<CR>ggyG:call cursor(l,c)<CR>:echo 'yanked whole file'<CR>

vnoremap <C-a> :call Increment()<CR>
" }}}
" fix the esc/alt mapping problem in terminal vim {{{
if !has('gui_running')
  set ttimeoutlen=10
  augroup FastEscape
    autocmd!
    autocmd InsertEnter * set timeoutlen=0
    autocmd InsertLeave * set timeoutlen=2000
  augroup END
endif
" }}}
" easily toggle command line window with Q {{{
nnoremap Q q:
augroup CmdWindow
  autocmd!
  autocmd CmdwinEnter * nnoremap <buffer><silent> Q :q<CR>
  autocmd CmdwinEnter * nnoremap <buffer><silent> <C-c> <Esc>
augroup END
" }}}
" c/C/x/X operators go to own registers instead of unnamed[plus] register specified by 'clipboard' {{{
nnoremap <expr> c (v:register == '+' \|\| v:register == '*') ? '"cc' : 'c'
nnoremap <expr> C (v:register == '+' \|\| v:register == '*') ? '"cC' : 'C'
nnoremap <expr> x (v:register == '+' \|\| v:register == '*') ? '"xx' : 'x'
nnoremap <expr> X (v:register == '+' \|\| v:register == '*') ? '"xX' : 'X'
" }}}
" quickfix maps {{{
augroup QuickFix
  autocmd!
  autocmd FileType qf setlocal nosplitbelow nosplitright norelativenumber
  autocmd FileType qf setlocal switchbuf=""
  autocmd FileType qf nnoremap <buffer><silent> <CR> <CR>zvzz
  autocmd FileType qf nnoremap <buffer><silent> t  <C-w><CR><C-w>Tzvzz
  autocmd FileType qf nnoremap <buffer><silent> T  <C-w><CR><C-w>TzvzzgT<C-w>j
  autocmd FileType qf nnoremap <buffer><silent> o  <CR>zvzz
  autocmd FileType qf nnoremap <buffer><silent> O  <CR>zvzz<C-w>j
  autocmd FileType qf nnoremap <buffer><silent> go <CR>:cclose <Bar> lclose<CR>zvzz
  autocmd FileType qf nnoremap <buffer><silent> s  <C-w><CR>zvzz
  autocmd FileType qf nnoremap <buffer><silent> S  <C-w><CR>zvzz<C-w>p
  autocmd FileType qf nnoremap <buffer><silent> v  :let g:qf_height = winheight('.')<CR><C-w><CR><C-w>L<C-w>p<C-w>J:resize <C-r>=g:qf_height<CR><CR><C-w>pzvzz
  autocmd FileType qf nnoremap <buffer><silent> V  :let g:qf_height = winheight('.')<CR><C-w><CR><C-w>L<C-w>p<C-w>J:resize <C-r>=g:qf_height<CR><CR><C-w>pzvzz<C-w>p
  autocmd FileType qf nnoremap <buffer><silent> q  :cclose <Bar> lclose<CR>zz
  autocmd FileType qf nnoremap <buffer><silent> <leader>q  :cclose <Bar> lclose<CR>zz
augroup END
" }}}
" Text Object / targets.vim maps {{{
" TODO this way of customizing targets is deprecated, see targets#mappings#extend()
let g:targets_pairs       = '()b {}c []r <>g'
let g:targets_quotes      = "\"d 's `t"
" }}}
" k and j add to jumplist {{{
nnoremap <expr> k (v:count > 4 ? "m'" . v:count . 'k' : (v:count == 0 ? 'gk' : 'k'))
nnoremap <expr> j (v:count > 4 ? "m'" . v:count . 'j' : (v:count == 0 ? 'gj' : 'j'))
" }}}
" defualt comma leader maps {{{
nnoremap <silent> <leader>a    :nohlsearch<CR>
nnoremap <silent> <leader>b    :BrightestToggle<CR>
"                         c    nerdcommenter maps
nnoremap <silent> <leader>f    :call ColumnFlash()<CR>
"                      [gG]    fugitive, signify maps below
"                 <leader>l    ListToggle
" nnoremap <silent> <leader>m    :Neogit<CR>
nnoremap <silent> <leader>p    "0p
nnoremap <silent> <leader>P    "0P
"                        rt    " term/tmux/repl maps
nnoremap <silent> <leader>q    :q<CR>
nnoremap          <leader>sf   :call SourceCurrentFunction()<CR>
nnoremap <silent> <leader>sh   :echo map(synstack(line('.'),col('.')),'synIDattr(v:val,"name")')<CR>
nnoremap          <leader>sv   :source %<CR>
nnoremap          <leader>sV   :source $MYVIMRC<CR>
vnoremap          <leader>sv   :Source %<CR>
nnoremap <silent> <leader>S    :let c=col(".")<CR>V:Source<CR>:call cursor(line("."),c)<CR>
vnoremap <silent> <leader>S    <Esc>:let g:c=col(".")<CR>gv:Source<CR>:call cursor(line("."),g:c)<CR>
nnoremap <silent> <leader>ts   :write \| edit \| TSBufEnable highlight<CR>
nnoremap <silent> <leader>u    yyp^v$r=
nnoremap <silent> <leader>w    :w!<CR>
nnoremap <silent> <leader>x    :x!<CR>
nnoremap <silent> <leader>zs   :syntax sync fromstart<CR>

nnoremap          <leader>gh  :SignifyToggleHighlight<CR>
nnoremap          <leader>gt  :SignifyToggle<CR>
nnoremap          <leader>gf  :SignifyFold<CR>

nnoremap <silent> <leader>ga  :Git add %:p<CR><CR>
nnoremap          <leader>gb  :Gbranch<Space>
nnoremap <silent> <leader>gB  :Git blame<CR>
nnoremap <silent> <leader>gc  :Git commit --verbose<CR>
nnoremap          <leader>gC  :Gcheckout<Space>
nnoremap <silent> <leader>gd  :Gdiffsplit!<CR>
nnoremap          <leader>ge  :Gedit<Space>
nnoremap <silent> <leader>glf :silent Glog -- %<CR>
nnoremap <silent> <leader>gr  :Gread<CR>
nnoremap <silent> <leader>gs  :Git<CR>
nnoremap <silent> <leader>gw  :Gwrite<CR>

augroup RunningAndTesting
  " https://vi.stackexchange.com/questions/15431/how-can-i-make-the-neovim-terminal-run-the-current-file-in-python
  " could probably be more sophisticated using neoterm / iron.nvim / sniprun / vim-terminator, but not needed for now
  " https://austeretechnology.wordpress.com/2017/07/18/a-ruby-repl-workflow-with-neovim-and-neoterm/
  autocmd!
  autocmd FileType python  nnoremap <buffer><leader>r :call RunAndReturn('terminal python %')<CR>
  autocmd FileType python  nnoremap <buffer><leader>t :call RunAndReturn('terminal pytest %')<CR>
  autocmd FileType python  nnoremap <buffer><leader>a :call DeleteTerminalBuffers()<CR>
augroup END

function! RunAndReturn(cmd)
  call DeleteTerminalBuffers()
  if winwidth(0) >= 235
    let termwidth = winwidth(0) - 145
    execute termwidth.'vsplit'
  else
    split
  endif
  execute a:cmd
  wincmd p
endfunction

function! DeleteTerminalBuffers()
  let buffers = filter(range(1, bufnr('$')), 'buflisted(v:val) && bufname(v:val) =~ "term://"')
  if !empty(buffers)
    execute 'bdelete! '.join(buffers, ' ')
  endif
endfunction
" }}}
" space leader maps. fzf + vim-plug {{{
let g:fzf_command_prefix = 'FZF' " easy autocompletion
nnoremap <silent> <Space>b   :FZFBuffers<CR>
nnoremap          <Space>c   :FZFCommands<CR>
" TODO FZFFiles doesn't show preview correctly for files with colons in the name (noticed when working with my vimtmp.sh)
nnoremap <silent> <Space>f   :FZFFiles<CR>
nnoremap <silent> <Space>F   :FZFFindCache<CR>
nnoremap <silent> <Space>g   :FZFGitFiles<CR>
nnoremap          <Space>h   :FZFHelptags<CR>
nnoremap <silent> <Space>H   :FZFHistory<CR>
nnoremap <silent> <Space>l   :FZFLines<CR>
nnoremap <silent> <Space>L   :FZFBLines<CR>
nnoremap <silent> <Space>m   :FZFMarks<CR>
nnoremap <silent> <Space>M   :FZFMaps<CR>
nnoremap          <Space>s   :FZFSnippets<CR>
nnoremap          <Space>u   :FZFUrls<CR>
nnoremap <silent> <Space>v   :FZFCommits<CR>
nnoremap <silent> <Space>V   :FZFBCommits<CR>
nnoremap <silent> <Space>w   :FZFWindows<CR>
nnoremap <silent> <Space>x   :FZFRg<CR>
nnoremap          <Space>X   :FZFRg<Space>
nnoremap <silent> <Space>:   :FZFHistory:<CR>
nnoremap <silent> <Space>/   :FZFHistory/<CR>

nnoremap <Space>pi       :PlugInstall<CR>
nnoremap <Space>pu       :PlugUpdate<CR>
nnoremap <Space>pU       :PlugUpgrade<CR>
" }}}
" ctrl normal mode {{{
nnoremap <C-n>              gt
nnoremap <C-p>              gT
" }}}
" ctrl insert mode {{{
inoremap <C-a>   <Home>
inoremap <C-c>   <Esc>`^
inoremap <C-e>   <End>
inoremap <Esc>   <Esc>`^
" }}}
" alt normal mode {{{
" move windows
exec 'nnoremap <silent> ' . AltShiftmap('H') . ' :execute "ObviousResizeLeft " . (winwidth(0) * 1/6)<CR>'
exec 'nnoremap <silent> ' . AltShiftmap('J') . ' :execute "ObviousResizeDown " . (winheight(0) * 1/6)<CR>'
exec 'nnoremap <silent> ' . AltShiftmap('K') . ' :execute "ObviousResizeUp " . (winheight(0) * 1/6)<CR>'
exec 'nnoremap <silent> ' . AltShiftmap('L') . ' :execute "ObviousResizeRight " . (winwidth(0) * 1/6)<CR>'
exec 'nnoremap <silent> ' . Altmap('h') . ' :execute "ObviousResizeLeft 1"<CR>'
exec 'nnoremap <silent> ' . Altmap('j') . ' :execute "ObviousResizeDown 1"<CR>'
exec 'nnoremap <silent> ' . Altmap('k') . ' :execute "ObviousResizeUp 1"<CR>'
exec 'nnoremap <silent> ' . Altmap('l') . ' :execute "ObviousResizeRight 1"<CR>'
exec 'nnoremap <silent> ' . Altmap('m') . ' :match none<CR>'
exec 'nnoremap <silent> ' . Altmap('n') . ' :tabmove +1<CR>'
exec 'nnoremap <silent> ' . Altmap('p') . ' :tabmove -1<CR>'
exec 'nnoremap <silent> ' . Altmap('q') . ' :quitall<CR>'
exec 'nnoremap <silent> ' . Altmap('1') . ' 1gt'
exec 'nnoremap <silent> ' . Altmap('2') . ' 2gt'
exec 'nnoremap <silent> ' . Altmap('3') . ' 3gt'
exec 'nnoremap <silent> ' . Altmap('4') . ' 4gt'
exec 'nnoremap <silent> ' . Altmap('5') . ' 5gt'
exec 'nnoremap <silent> ' . Altmap('6') . ' 6gt'
exec 'nnoremap <silent> ' . Altmap('7') . ' 7gt'
exec 'nnoremap <silent> ' . Altmap('8') . ' 8gt'
exec 'nnoremap <silent> ' . Altmap('9') . ' 9gt'
exec 'nnoremap <silent> ' . Altmap('0') . ' :tablast<CR>'
" }}}
" neovim terminal maps {{{
let g:terminal_scrollback_buffer_size = 100000
if has('nvim')
  augroup fzf_setup
    autocmd!
    autocmd TermOpen term://*FZF tnoremap <silent> <buffer><nowait> <esc> <c-c>
  augroup END
end
" }}}
" }}}
" vim: foldmethod=marker
