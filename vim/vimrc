" Initial setup {{{
colorscheme guimiromod
runtime macros/matchit.vim
set guifont=DejaVuSansMonoforPowerline\ 11
" NeoBundle {{{
let s:neobundle_dir=expand('~/.vim/bundle/neobundle.vim')
if !isdirectory(s:neobundle_dir)
  execute 'silent !git clone https://github.com/Shougo/neobundle.vim.git ' . s:neobundle_dir
endif

if has('vim_starting')
  set nocompatible
  execute 'set runtimepath^=' . s:neobundle_dir
endif

call neobundle#rc(fnamemodify(s:neobundle_dir, ':h'))

NeoBundleFetch 'Shougo/neobundle.vim'
NeoBundle 'Shougo/vimproc.vim', { 'build' : { 'unix' : 'make -f make_unix.mak', }, }
NeoBundle 'amdt/vim-niji'
NeoBundle 'bling/vim-airline'
NeoBundle 'dockyard/vim-easydir'
NeoBundle 'gcmt/taboo.vim'
NeoBundle 'godlygeek/tabular'
NeoBundle 'itchyny/calendar.vim'
NeoBundle 'jamessan/vim-gnupg'
NeoBundle 'justinmk/vim-sneak'
NeoBundle 'majutsushi/tagbar'
NeoBundle 'mattn/gist-vim'
NeoBundle 'mattn/webapi-vim'
NeoBundle 'mhinz/vim-signify'
NeoBundle 'mhinz/vim-startify'
NeoBundle 'mhinz/vim-tmuxify'
NeoBundle 'milkypostman/vim-togglelist'
NeoBundle 'scrooloose/nerdcommenter'
NeoBundle 'scrooloose/syntastic'
NeoBundle 'sgur/unite-qf'
NeoBundle 'Shougo/neocomplete.vim'
NeoBundle 'Shougo/unite-help'
NeoBundle 'Shougo/unite-outline'
NeoBundle 'Shougo/unite.vim'
NeoBundle 'Shougo/vimfiler.vim'
NeoBundle 'Shougo/vinarise.vim'
NeoBundle 'SirVer/ultisnips'
NeoBundle 'sjl/gundo.vim'
NeoBundle 'tacroe/unite-mark'
NeoBundle 'thinca/vim-quickrun'
NeoBundle 'tmhedberg/SimpylFold'
NeoBundle 'tommcdo/vim-exchange'
NeoBundle 'tpope/vim-abolish'
NeoBundle 'tpope/vim-dispatch'
NeoBundle 'tpope/vim-eunuch'
NeoBundle 'tpope/vim-fugitive'
NeoBundle 'tpope/vim-obsession'
NeoBundle 'tpope/vim-repeat'
NeoBundle 'tpope/vim-surround'
NeoBundle 'tpope/vim-unimpaired'
NeoBundle 'tsukkee/unite-tag'
NeoBundle 'ujihisa/unite-locate'
NeoBundle 'Valloric/MatchTagAlways'
NeoBundle 'vim-scripts/SyntaxRange'
NeoBundle 'xolox/vim-misc'

NeoBundle 'bitbucket:abudden/TagHighlight'
NeoBundleCheck
" }}}
" }}}
" Misc {{{
" Mail / Mutt {{{
augroup MUTT " spell check, textwidth, F1-3 for wrapping paragraphs in useful ways
  autocmd BufRead /tmp/mutt-* set tw=72  " for email with mutt
  autocmd BufRead /tmp/mutt-* set spell  " <-- vim 7 required
  autocmd BufRead /tmp/mutt-* nmap  <F1>  gqap
  autocmd BufRead /tmp/mutt-* nmap  <F2>  gqqj
  autocmd BufRead /tmp/mutt-* nmap  <F3>  kgqj
  autocmd BufRead /tmp/mutt-* map!  <F1>  <ESC>gqapi
  autocmd BufRead /tmp/mutt-* map!  <F2>  <ESC>gqqji
  autocmd BufRead /tmp/mutt-* map!  <F3>  <ESC>kgqji
augroup END
" }}}
" Fix borders of fullscreen GUI {{{
if has('gui_gtk') && has('gui_running')
    let s:border = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'gui')
    exe 'silent !echo ''style "vimfix" { bg[NORMAL] = "' . escape(s:border, '#') . '" }'''.
                \' > ~/.gtkrc-2.0.mine'
    exe 'silent !echo ''widget "vim-main-window.*GtkForm" style "vimfix"'''.
                \' >> ~/.gtkrc-2.0.mine'
endif
" }}}
" Return to last edit position when opening files {{{
augroup ReturnToLast
  autocmd BufReadPost *
       \ if line("'\"") > 0 && line("'\"") <= line("$") |
       \   exe "normal! g`\"" |
       \ endif
augroup END
" }}}
" StripTrailingWhitespace function {{{
function! StripTrailingWhitespace()
  let l = line(".")
  let c = col(".")
  %s/\s\+$//e
  call cursor(l, c)
endfunction
" }}}
" Line join {{{
if v:version > 703 || v:version == 703 && has("patch541")
  set formatoptions+=j  " delete comment character when joining commented lines
endif
set nojoinspaces        " use only one space after a period when joining lines
" }}}
" Command mode maps and abbreviations {{{
command! CD cd %:p:h
cnoremap %% <C-R>=fnameescape(expand('%:h')).'/'<CR>
cnoreabbrev te tabedit
cnoreabbrev sv source ~/.vim/vimrc
cnoreabbrev sc source ~/.vim/colors/guimiromod.vim

cnoremap <C-a>  <Home>
cnoremap <C-p>  <Up>
cnoremap <C-n>  <Down>
cnoremap <C-j>  <S-Left>
cnoremap <C-l>  <S-Right>
" }}}
" SyntaxRange autocmds {{{
" last parameter is optional and can be any highlight group, determines delimiter colors
augroup SyntaxNotes
  autocmd BufEnter *.txt call SyntaxRange#Include('@begin=text@',  '@end=text@',  'text',  'Tabline')
  autocmd BufEnter *.txt call SyntaxRange#Include('@begin=c@',     '@end=c@',     'c',     'Comment')
  autocmd BufEnter *.txt call SyntaxRange#Include('@begin=cpp@',   '@end=cpp@',   'cpp',   'Comment')
  autocmd BufEnter *.txt call SyntaxRange#Include('@begin=lisp@',  '@end=lisp@',  'lisp',  'Comment')
  autocmd BufEnter *.txt call SyntaxRange#Include('@begin=ocaml@', '@end=ocaml@', 'ocaml', 'Comment')
augroup END
" }}}
" FileType autocmds {{{
augroup FileTypeSettings
  autocmd FileType c,cpp,java,php,ruby,ocaml,python,text
          \ autocmd BufWritePre <buffer> :call StripTrailingWhitespace()

  autocmd FileType tex nnoremap <leader>w :w!<CR>
                  \:call system("rubber --pdf --warn all " . shellescape(expand('%:p')))<CR>
                  \:call system("killall -HUP mupdf")<CR>
  autocmd FileType tex nnoremap <leader>lv :!mupdf %:r.pdf &<CR><CR>

  autocmd FileType gitcommit setlocal nocursorline nocursorcolumn
  autocmd FileType lisp setlocal foldmethod=indent foldlevel=0
  autocmd FileType make set noexpandtab shiftwidth=4 tabstop=4
  autocmd FileType ocaml call MapInterpreter('ocaml', 'ocaml')
  autocmd FileType vimfiler set relativenumber
  autocmd BufRead  .tags set filetype=tags
augroup END
" }}}
" }}}
" Functions {{{
" CustomMatch function {{{
function! CustomMatch(pattern)
  let search_string = "/" . a:pattern . "/"
  execute 'match MatchTarget ' . search_string
endfunction
command! -nargs=1 MatchText call CustomMatch(<f-args>)
cnoreabbrev mt MatchText
" }}}
" Copy function {{{
" complement to unimpaired Move, ]e
function! Copy(cmd, count, map) abort
  normal! m`
  exe 'copy'.a:cmd.a:count
  norm! ``
  if a:map == 'MoveDown' || a:map == 'MoveUp' || a:map == 'MoveAbs'
    norm! dd
  endif
  silent! call repeat#set("\<Plug>my".a:map, a:count)
endfunction

nnoremap <silent> <Plug>myCopyUp   :<C-U>call Copy('--',v:count1,'CopyUp')<CR>
nnoremap <silent> <Plug>myCopyDown :<C-U>call Copy('+',v:count1,'CopyDown')<CR>
xnoremap <silent> <Plug>myCopyUp   :<C-U>exe 'exe "normal! m`"<Bar>''<,''>copy--'.v:count1<CR>``
xnoremap <silent> <Plug>myCopyDown :<C-U>exe 'exe "normal! m`"<Bar>''<,''>copy''>+'.v:count1<CR>``

nnoremap <silent> <Plug>myMoveUp   :<C-U>call Copy('--',v:count1,'MoveUp')<CR>
nnoremap <silent> <Plug>myMoveDown :<C-U>call Copy('+',v:count1,'MoveDown')<CR>
xnoremap <silent> <Plug>myMoveUp   :<C-U>exe 'exe "normal! m`"<Bar>''<,''>copy--'.v:count1<CR>``gvd
xnoremap <silent> <Plug>myMoveDown :<C-U>exe 'exe "normal! m`"<Bar>''<,''>copy''>+'.v:count1<CR>``gvd

nnoremap <silent> <Plug>myCopyAbs  :<C-U>call Copy('',v:count1,'CopyAbs')<CR>
nnoremap <silent> <Plug>myMoveAbs  :<C-U>call Copy('',v:count1,'MoveAbs')<CR>

nmap [z <Plug>myCopyUp
nmap ]z <Plug>myCopyDown
xmap [z <Plug>myCopyUp
xmap ]z <Plug>myCopyDown

nmap [m <Plug>myMoveUp
nmap ]m <Plug>myMoveDown
xmap [m <Plug>myMoveUp
xmap ]m <Plug>myMoveDown

nmap [j <Plug>myCopyAbs
nmap ]j <Plug>myMoveAbs
" }}}
" VimGrep wrapper function + todo searches {{{
function! VimGrep(pattern, target, cw)
  execute 'silent! vim /' . a:pattern . '/gj ' . a:target . a:cw
  redraw!
  echom   'silent! vim /' . a:pattern . '/gj ' . a:target . a:cw
endfunction
command! -nargs=1 -bar Bufsearch call VimGrep(<f-args>,   '%',      ' | cw')
command! -nargs=1 -bar Argsearch call VimGrep(<f-args>,   '##',     ' | cw')
command! -nargs=1 -bar Allsearch call VimGrep(<f-args>,   './**/*', ' | cw')
command! -nargs=0 -bar Buftodo   call VimGrep('\CTODO:*', '%',      ' | cw')
command! -nargs=0 -bar Argtodo   call VimGrep('\CTODO:*', '##',     ' | cw')
command! -nargs=0 -bar Alltodo   call VimGrep('\CTODO:*', './**/*', ' | cw')
cnoreabbrev bufsearch  Bufsearch
cnoreabbrev argsearch  Argsearch
cnoreabbrev allsearch  Allsearch
cnoreabbrev buftodo    Buftodo
cnoreabbrev argtodo    Argtodo
cnoreabbrev alltodo    Alltodo
" }}}
" Qargs, Qdof, Qdol {{{
" :Qargs will populate the arglist with the files in the quickfix list
command! -nargs=0 -bar Qargs execute 'args' QuickfixFilenames()
cnoreabbrev qargs Qargs

" :Qdol applies an arbitrary command to every line found by :vimgrep (:Qdol normal @q)
command! -nargs=1 Qdol try | sil cfirst |
  \ while 1 | exec <q-args> | sil cn | endwhile |
  \ catch /^Vim\%((\a\+)\)\=:E\%(553\|42\):/ |
  \ endtry
cnoreabbrev qdol Qdol

" :Qdof applies an arbitrary command to every file found by :vimgrep (at line of first match)
command! -nargs=1 Qdof try | sil cfirst |
  \ while 1 | exec <q-args> | sil cnf | endwhile |
  \ catch /^Vim\%((\a\+)\)\=:E\%(553\|42\):/ |
  \ endtry
cnoreabbrev qdof Qdof

" implementation of Qargs
function! QuickfixFilenames()
  " Building a hash ensures we get each buffer only once
  let buffer_numbers = {}
  for quickfix_item in getqflist()
    let buffer_numbers[quickfix_item['bufnr']] = bufname(quickfix_item['bufnr'])
  endfor
  return join(map(values(buffer_numbers), 'fnameescape(v:val)'))
endfunction
" }}}
" Location list loop function {{{
function! WrapCommand(direction)
  if a:direction == "up"
    try
      lprevious
    catch /^Vim\%((\a\+)\)\=:E553/
      llast
    endtry
  elseif a:direction == "down"
    try
      lnext
    catch /^Vim\%((\a\+)\)\=:E553/
      lfirst
    endtry
  endif
endfunction

" nnoremap <Home> :call WrapCommand("up")<CR>
" nnoremap <End>  :call WrapCommand("down")<CR>
" }}}
" Visual mode increment function {{{
function! Increment()
  let a = line('.') - line("'<")
  let c = virtcol("'<")
  if a > 0
    execute 'normal! '.c.'|'.a."\<C-a>"
  endif
  normal `<
endfunction
" }}}
" VisualStarSearch function and maps {{{
function! VSetSearch(cmdtype) " makes * and # work on visual mode too.
  let temp = @s
  norm! gv"sy
  let @/ = '\V' . substitute(escape(@s, a:cmdtype.'\'), '\n', '\\n', 'g')
  let @s = temp
endfunction

xnoremap * :<C-u>call VSetSearch('/')<CR>/<C-R>=@/<CR><CR>
xnoremap # :<C-u>call VSetSearch('?')<CR>?<C-R>=@/<CR><CR>
" }}}
" Ranger file chooser function {{{
" only works on a single file. more just for fun than practicality
function! RangerChooser()
    exec "silent !ranger --choosefile=/tmp/chosenfile " . expand("%:p:h")
    if filereadable('/tmp/chosenfile')
        exec 'edit ' . system('cat /tmp/chosenfile')
        call system('rm /tmp/chosenfile')
    endif
    redraw!
endfunction
" }}}
" GitPush with dispatch function {{{
function! GitPush()
  if !exists('b:dispatch')
    let b:dispatch = "git push"
    Dispatch!
  else
    let foo = b:dispatch
    let b:dispatch = "git push"
    Dispatch!
    let b:dispatch = foo
  endif
endfunction
" }}}
" GenerateRunCommand function {{{
function! GenerateRunCommand(...)
  if a:0 == 1
    let ftype = a:1
  else
    let ftype = &filetype
  endif

  if ftype == 'c' || ftype == 'cpp'
    return shellescape(expand('%:p:r'))
  elseif ftype == 'sh'
    return 'bash ' . shellescape(expand('%'))
  elseif ftype == 'python'
    return 'python ' . shellescape(expand('%'))
  elseif ftype == 'ocaml'
    return 'ocaml ' . shellescape(expand('%'))
  elseif ftype == 'lisp'
    return 'clisp ' . shellescape(expand('%'))
  endif

endfunction
" }}}
" GenerateBuildCommand function {{{
function! GenerateBuildCommand()
  if &filetype == 'c'
    let my_compiler = 'gcc'
  elseif &filetype == 'cpp'
    let my_compiler = 'g++'
  elseif &filetype == 'ocaml'
    let my_compiler = 'ocamlc'
  endif

  return my_compiler . ' ' . shellescape(expand('%:p')) . ' -o ' . shellescape(expand('%:p:r'))
endfunction
" }}}
" Run shell command, put output in split function {{{
function! s:ExecuteInShell(command, bang)
  let _ = a:bang != '' ? s:_ : a:command == '' ? '' : join(map(split(a:command), 'expand(v:val)'))
  if (_ != '')
    let s:_ = _
    let bufnr = bufnr('%')
    let winnr = bufwinnr('^' . _ . '$')
    silent! execute  winnr < 0 ? 'belowright new ' . fnameescape(_) : winnr . 'wincmd w'
    setlocal buftype=nowrite bufhidden=wipe nobuflisted noswapfile wrap number
    silent! :%d
    let message = 'Execute ' . _ . '...'
    call append(0, message)
    echo message
    silent! 2d | resize 1 | redraw
    silent! execute 'silent! %!'. _
    silent! execute 'resize ' . line('$')
    silent! execute 'syntax on'
    silent! execute 'autocmd BufUnload <buffer> execute bufwinnr(' . bufnr . ') . ''wincmd w'''
    silent! execute 'autocmd BufEnter <buffer> execute ''resize '' .  line(''$'')'
    silent! execute 'nnoremap <silent> <buffer> <CR> :call <SID>ExecuteInShell(''' . _ . ''', '''')<CR>'
    silent! execute 'nnoremap <silent> <buffer> <LocalLeader>r :call <SID>ExecuteInShell(''' . _ . ''', '''')<CR>'
    silent! execute 'nnoremap <silent> <buffer> <LocalLeader>g :execute bufwinnr(' . bufnr . ') . ''wincmd w''<CR>'
    nnoremap <silent> <buffer> <C-W>_ :execute 'resize ' . line('$')<CR>
    silent! syntax on
  endif
endfunction

command! -complete=shellcmd -nargs=* -bang Shell call s:ExecuteInShell(<q-args>, '<bang>')
" }}}
" Create maps to run buffer/visual selection through interpreter {{{
function! MapInterpreter(ftype, interpreter)
  execute 'nnoremap <leader>i :silent! bdelete /tmp/' . a:ftype . '<CR>:15split /tmp/' . a:ftype . ' \| %d \|setlocal ft=' . a:ftype . ' \| setlocal autowrite \| r!' . a:interpreter . ' < #<CR>:normal ggdd<CR>:silent w \| echo "did some ' . a:interpreter . '"<CR><C-w>w'

  execute 'vnoremap <leader>i y:silent! bdelete /tmp/' . a:ftype . '<CR>:15split /tmp/' . a:ftype . ' \| %d _ \| put \| write<CR>:normal! gg<CR>:setlocal ft=' . a:ftype . ' \| setlocal autowrite \| r!' . a:interpreter . ' < %<CR>:normal! jdGggdd<CR>:silent w \| echo "did some ' . a:interpreter . '"<CR><C-w>w'
endfunction
" }}}
" }}}
" Plugins {{{
" airline {{{
let g:airline_theme             = "simple"
let g:airline_detect_modified   = 1
let g:airline_detect_paste      = 1
let g:airline_inactive_collapse = 1
let g:airline_readonly_symbol   = ''
let g:airline_left_alt_sep      = ''
let g:airline_right_alt_sep     = ''

""" FANCY SETTINGS
" let g:airline_left_sep      = ''
" let g:airline_right_sep     = ''
" let g:airline_branch_prefix = ' '
" let g:airline_section_z     = "%l/%L:C%c"

""" MINIMAL SETTINGS
let g:airline_left_sep  = ''
let g:airline_right_sep = ''
let g:airline_section_z = "%l/%L:C%v"

let g:airline#extensions#whitespace#symbol              = 'Ξ'
let g:airline#extensions#whitespace#trailing_format     = 's[%s]'
let g:airline#extensions#whitespace#mixed_indent_format = 't[%s]'
let g:airline#extensions#hunks#enabled                  = 1
let g:airline#extensions#hunks#non_zero_only            = 1

let g:airline_theme_patch_func = 'AirlineThemePatch'
function! AirlineThemePatch(palette)
  if g:airline_theme == 'simple'
    for colors in values(a:palette.inactive)
      let colors[2] = 231  " text color of split statusline
      let colors[3] = 58   " background color of split statusline
    endfor
  endif
endfunction
" }}}
" calendar {{{
let g:calendar_google_calendar=1
let g:calendar_google_task=1
augroup calendar
  autocmd FileType calendar call s:calendar_my_settings()
augroup END

function! s:calendar_my_settings()
  nmap <buffer> i <Plug>(calendar_up)
  nmap <buffer> j <Plug>(calendar_left)
  nmap <buffer> k <Plug>(calendar_down)
  nmap <buffer> l <Plug>(calendar_right)
  nmap <buffer> h <Plug>(calendar_start_insert)
  nmap <buffer> H <Plug>(calendar_start_insert_head)

  nmap <buffer> <BS> <Plug>(calendar_left)
  nmap <buffer> <C-h> <Plug>(calendar_left)

  nmap <buffer> <C-n> <Plug>(calendar_view_right)
  nmap <buffer> <C-p> <Plug>(calendar_view_left)
endfunction
" }}}
" dispatch {{{
augroup DISPATCH
  autocmd FileType c,cpp,sh,python,ocaml,lisp     let b:dispatch = GenerateRunCommand()
augroup END
" }}}
" easymotion {{{
" stop some annoying maps from getting set
let g:EasyMotion_special_select_phrase = 0
let g:EasyMotion_special_select_line   = 0
" }}}
" exchange {{{
" default is cx, this prevents map lag when hitting 'c' in visual mode
vmap s <Plug>(Exchange)
" }}}
" fugitive {{{
autocmd User fugitive  " .. to go back up to parent directory when browsing git tree
  \ if fugitive#buffer().type() =~# '^\%(tree\|blob\)$' |
  \   nnoremap <buffer> .. :edit %:h<CR> |
  \ endif
autocmd BufReadPost fugitive://* set bufhidden=delete  " stop fugitive from making tons of buffers

function! FugitiveUnmap(key)
  silent! exe 'nunmap <buffer> '.a:key
endfunction

augroup FugitiveCMDs
  autocmd!
  autocmd FileType gitcommit,git autocmd FugitiveCMDs CursorMoved <buffer>
        \ call FugitiveUnmap('i') | autocmd! FugitiveCMDs * <buffer>
augroup END
" }}}
" gist {{{
let g:gist_post_private = 1 " gists are private by default
" }}}
" gundo {{{
let g:gundo_width          = 40
let g:gundo_preview_height = 40
" }}}
" match tag {{{
let g:mta_filetypes = {
    \ 'html' : 1,
    \ 'xhtml' : 1,
    \ 'xml' : 1,
    \ 'jinja' : 1,
    \ 'php' : 1,
    \}
" }}}
" neocomplete {{{
let g:neocomplete#enable_at_startup                 = 1
let g:neocomplete#enable_smart_case                 = 1
let g:neocomplete#enable_auto_select                = 1
let g:neocomplete#enable_refresh_always             = 0  " default is zero, heavy feature
let g:neocomplete#sources#syntax#min_keyword_length = 3
let g:neocomplete#lock_buffer_name_pattern          = '\*ku\*'

" use words with at least 7 letters from google-10000 for completion in .txt files
let g:neocomplete#sources#dictionary#dictionaries = {'text':'/home/james/dotfiles/vim/7mydict'}

" Define keyword.
if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings.
inoremap <expr> <C-k>    neocomplete#undo_completion()
inoremap <expr> <C-f>    neocomplete#complete_common_string()
inoremap <expr> <TAB>    pumvisible() ? "\<C-n>" : "\<TAB>"
inoremap <expr> <CR>     pumvisible() ? neocomplete#close_popup() : "\<CR>"
inoremap <expr> <C-h>    neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr> <BS>     neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr> <C-d>    neocomplete#cancel_popup()

" Enable omni completion.
autocmd FileType css            setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown  setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript     setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python         setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml            setlocal omnifunc=xmlcomplete#CompleteTags

" Enable heavy omni completion.
if !exists('g:neocomplete#sources#omni#input_patterns')
  let g:neocomplete#sources#omni#input_patterns = {}
endif
"let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
"let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
"let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
" }}}
" nerdcommenter {{{
let NERDSpaceDelims     = 1
let NERDCompactSexyComs = 0
" }}}
" netrw {{{
let g:netrw_bufsettings = 'noma nomod nu nobl nowrap ro'
function! Netrwmap(lhskey, rhskey, pattern)
  if -1 != stridx(maparg(a:lhskey,"n"), a:pattern)
    exec 'nnoremap <buffer> <silent> <leader>'.a:lhskey.' '.maparg(a:rhskey,'n')
    silent! exe 'nunmap <buffer> '.a:lhskey
  else
    exec 'nmap <buffer><silent> ' . a:lhskey.' '.a:rhskey
  endif
endfunction

augroup NetrwCMDs
  autocmd!
  autocmd FileType netrw autocmd NetrwCMDs CursorMoved <buffer>
        \ call Netrwmap('i', 'i', '_Net') | call Netrwmap('I', 'I', '_Net') |
        \ call Netrwmap('j', '-', '_Net') | call Netrwmap('l', '<CR>', '_Net') |
        \ autocmd! NetrwCMDs * <buffer>
augroup END
" }}}
" niji {{{
let g:niji_matching_filetypes = ['lisp']
let g:niji_dark_colours = [
                        \ [ '82',  '#5Fff00'],
                        \ [ '202', '#FF5F00'],
                        \ [ '231', '#FFFFFF'],
                        \ [ '201', '#FF00FF'],
                        \ [ '226', '#FFFF00'],
                        \ [ '196', '#FF0000']
                        \ ]
" }}}
" paredit {{{
let g:paredit_leader = '\'
" }}}
" simplyfold {{{
let g:SimplyFold_docstring_preview = 0
" }}}
" signify {{{
let g:signify_disable_by_default = 1            " disable run by default
let g:signify_vcs_list           = [ 'git' ]    " I only use git for now
let g:signify_mapping_next_hunk  = '<leader>gk'
let g:signify_mapping_prev_hunk  = '<leader>gi'
let g:signify_sign_change        = '~'
" }}}
" slimv {{{
let g:slimv_leader        = '\'
let g:slimv_repl_wrap     = 0 " stop j and k from getting remapped. unfortunately also stops REPL wrapping
let g:lisp_rainbow        = 1 " will get overridden by niji, but works in @begin=*@ blocks
let g:slimv_swank_cmd     = '! urxvt -e sbcl --load /usr/share/common-lisp/source/slime/start-swank.lisp &'
let g:slimv_swank_clojure = '! urxvt -e lein swank &'
" }}}
" sneak  {{{
let g:sneak#use_ic_scs = 1
xmap <nop> <Plug>VSneakForward
" }}}
" startify {{{
let g:startify_list_order        = ['bookmarks', 'dir', 'files', 'sessions']
let g:startify_bookmarks         = [ '~/dotfiles/vim/vimrc', '~/dotfiles/aliases', '~/Dropbox/todo/TODO.txt' ]
let g:startify_files_number      = 7
let g:startify_session_detection = 1 " show session when Session.vim is found in current directory
let g:startify_session_autoload  = 0  " opening directories with a Session.vim will have it auto load
let g:startify_change_to_dir     = 1     " when opening file or bookmark, change to its directory
let g:startify_custom_indices    = ['a','f','h','j','k','l','w','r','u','o','p','z','x','n','m']
let g:startify_custom_header     = [
  \ '    /\\\        /\\\   /\\\\\\\\\\\   /\\\\            /\\\\  ',
  \ '    \/\\\       \/\\\  \/////\\\///   \/\\\\\\        /\\\\\\  ',
  \ '     \//\\\      /\\\       \/\\\      \/\\\//\\\    /\\\//\\\  ',
  \ '       \//\\\    /\\\        \/\\\      \/\\\\///\\\/\\\/ \/\\\  ',
  \ '         \//\\\  /\\\         \/\\\      \/\\\  \///\\\/   \/\\\  ',
  \ '           \//\\\/\\\          \/\\\      \/\\\    \///     \/\\\  ',
  \ '             \//\\\\\           \/\\\      \/\\\             \/\\\  ',
  \ '               \//\\\         /\\\\\\\\\\\  \/\\\             \/\\\  ',
  \ '                 \///         \///////////   \///              \///   ',
  \ '',
  \ '',
  \ ]
" }}}
" syntastic {{{
let g:syntastic_c_compiler               = 'clang'
let g:syntastic_c_compiler_options       = ' -Wall'
let g:syntastic_cpp_compiler             = 'clang++'
let g:syntastic_cpp_compiler_options     = ' -Wall'
let g:syntastic_aggregate_errors         = 1         " display all errors
let g:syntastic_always_populate_loc_list = 1 " always put detecter errors in location list
let g:syntastic_error_symbol             = '✗✗'
let g:syntastic_warning_symbol           = '⚠⚠'
let g:syntastic_stl_format               = '[%E{E:%fe-%e}%B{|}%W{W:%fw-%w}]'
let g:syntastic_ignore_files = [
    \ '/home/james/Dropbox/Documents/UCLA/Y3Q1/CS161',
    \ '/home/james/Dropbox/Documents/UCLA/Y3Q1/CS118/Homework',
    \ '/home/james/Dropbox/Documents/UCLA/Y3Q1/CS144/vm-shared/project/src/']
" }}}
" taboo {{{
" let g:taboo_tab_format = "%N %1a%m "
let g:taboo_tab_format = "%N %f%m "
" }}}
" tagbar {{{
let g:tagbar_left             = 1   " default is to open on right
let g:tagbar_width            = 50  " default is 40
let g:tagbar_indent           = 1   " default is 2
let g:tagbar_show_linenumbers = 2   " relative line numbers
let g_tagbar_autoshowtag      = 1   " auto unfold any parents so highlighted tag is shown
let g:tagbar_sort             = 0   " sort tags by position in source file, not alphabetically
" }}}
" taghighlight {{{
if !exists('g:TagHighlightSettings')
  let g:TagHighlightSettings = {}
endif
let g:TagHighlightSettings['DoNotGenerateTags'] = 1 " don't generate tags
let g:TagHighlightSettings['TagFileName'] = '.tags'
let g:TagHighlightSettings['TypesFilePrefix'] = '.types' " make taghl file hidden
let g:TagHighlightSettings['ProjectConfigFileName'] = '.taghl_config.txt'
" }}}
" tmuxify {{{
let g:tmuxify_custom_command = 'tmux split-window -dp 25'
let g:tmuxify_map_prefix = ''
let g:tmuxify_run = {}

function! SetTmuxifyRun()
  if &filetype != ''
    execute 'let g:tmuxify_run.' . &filetype . '="' . GenerateRunCommand() . '"'
  endif
endfunction

augroup TMUXIFY
  autocmd BufEnter * call SetTmuxifyRun()
augroup END
" }}}
" togglelist {{{
let g:toggle_list_no_mappings   = 1       " don't use default mappings
let g:toggle_list_copen_command = "Copen" " use dispatch Copen wrapper
" }}}
" ultisnips {{{
let g:UltiSnipsExpandTrigger="<C-l>"
let g:UltiSnipsJumpForwardTrigger  = "<C-l>"
let g:UltiSnipsJumpBackwardTrigger = "<C-j>"
let g:UltiSnipsListSnippets        = "<C-j>"
" }}}
" unite {{{
let g:unite_cursor_line_highlight = "UniteSel"
if executable('ag')
  " Use ag in unite grep source.
  let g:unite_source_grep_command = 'ag'
  let g:unite_source_grep_default_opts =
  \ '--line-numbers --nocolor --nogroup --hidden --ignore ' .
  \  '''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.bzr'''
  let g:unite_source_grep_recursive_opt = ''
elseif executable('ack-grep')
  " Use ack in unite grep source.
  let g:unite_source_grep_command = 'ack-grep'
  let g:unite_source_grep_default_opts =
  \ '--no-heading --no-color -a -H'
  let g:unite_source_grep_recursive_opt = ''
endif
call unite#set_profile('outline', 'smartcase',  1)
let g:unite_source_outline_filetype_options = {
    \ '*': {
    \   'auto_update': 1,
    \   'auto_update_event': 'write',
    \   'ignore_types': ['comment'],
    \ },
    \}
augroup unite
  autocmd FileType unite call s:unite_my_settings()
augroup END
let g:unite_source_file_mru_long_limit      = 3000
let g:unite_source_directory_mru_long_limit = 3000
let g:unite_enable_start_insert             = 1
let g:unite_winheight                       = 20
let g:unite_split_rule                      = 'botright'
let g:unite_prompt                          = '» '
let g:unite_update_time                     = 500   " in milliseconds
let g:unite_source_rec_async_command        = 'ag --nocolor --nogroup --hidden -g ""'
let g:unite_source_history_yank_enable      = 1
let g:unite_locate_command                  = 'locate -i -l %d -e %s'
let g:unite_enable_ignore_case              = 1
let g:unite_enable_smart_case               = 1
call unite#filters#matcher_default#use(['matcher_fuzzy']) " enable fuzzy matching
function! s:unite_my_settings()
  nmap <buffer> <ESC>   <Plug>(unite_exit)
  nmap <buffer> <C-c>   <Plug>(unite_exit)
  imap <buffer> <C-c>   <Plug>(unite_exit)
  imap <buffer> <C-d>   <Plug>(unite_insert_leave)

  imap <buffer><expr> j unite#smart_map('j', '')
  imap <buffer> <Tab>   <Plug>(unite_select_next_line)
  imap <buffer> <S-Tab> <Plug>(unite_select_previous_line)
  imap <buffer> <C-w>   <Plug>(unite_delete_backward_path)
  nmap <buffer> '       <Plug>(unite_quick_match_default_action)
  imap <buffer> '       <Plug>(unite_quick_match_default_action)
  nmap <buffer> x       <Plug>(unite_quick_match_choose_action)
  imap <buffer><expr> x
          \ unite#smart_map('x', "\<Plug>(unite_quick_match_choose_action)")
  nmap <buffer> <C-z>   <Plug>(unite_toggle_transpose_window)
  imap <buffer> <C-z>   <Plug>(unite_toggle_transpose_window)
  nmap <buffer> <C-y>   <Plug>(unite_narrowing_path)
  imap <buffer> <C-y>   <Plug>(unite_narrowing_path)
  nmap <buffer> <C-j>   <Plug>(unite_toggle_auto_preview)
  nmap <buffer> <C-r>   <Plug>(unite_narrowing_input_history)
  imap <buffer> <C-r>   <Plug>(unite_narrowing_input_history)
  nnoremap <silent><buffer><expr> l
          \ unite#smart_map('l', unite#do_action('default'))

  let unite = unite#get_current_unite()
  if unite.buffer_name =~# '^search'
    nnoremap <silent><buffer><expr> r     unite#do_action('replace')
  else
    nnoremap <silent><buffer><expr> r     unite#do_action('rename')
  endif

  nnoremap <silent><buffer><expr> cd     unite#do_action('lcd')
  nnoremap <buffer><expr> S      unite#mappings#set_current_filters(
          \ empty(unite#mappings#get_current_filters()) ?
          \ ['sorter_reverse'] : [])

  imap <silent><buffer><expr> <C-s>     unite#do_action('above')
  imap <silent><buffer><expr> <C-k>     unite#do_action('below')
  imap <silent><buffer><expr> <C-x>     unite#do_action('left')
  imap <silent><buffer><expr> <C-v>     unite#do_action('right')
  imap <silent><buffer><expr> <C-t>     unite#do_action('tabopen')
  imap <silent><buffer><expr> <C-y>     unite#do_action('tabdrop')
  imap <silent><buffer><expr> <C-j>     unite#do_action('tabdrop')
  imap <silent><buffer><expr> <C-g>     unite#do_action('tabdrop')
  imap <buffer>               <C-o>     <Plug>(unite_toggle_mark_current_candidate)

  nmap <silent><buffer><expr> <C-s>     unite#do_action('above')
  nmap <silent><buffer><expr> <C-k>     unite#do_action('below')
  nmap <silent><buffer><expr> <C-x>     unite#do_action('left')
  nmap <silent><buffer><expr> <C-v>     unite#do_action('right')
  nmap <silent><buffer><expr> <C-t>     unite#do_action('tabopen')
  nmap <silent><buffer><expr> <C-y>     unite#do_action('tabdrop')
  nmap <silent><buffer><expr> <C-j>     unite#do_action('tabdrop')
  nmap <silent><buffer><expr> <C-g>     unite#do_action('tabdrop')
  nmap <buffer>               <C-o>     <Plug>(unite_toggle_mark_current_candidate)

  nmap <buffer> i     <Plug>(unite_loop_cursor_up)
  nmap <buffer> k     <Plug>(unite_loop_cursor_down)
  nmap <buffer> h     <Plug>(unite_insert_enter)
  nmap <buffer> H     <Plug>(unite_insert_head)
  nmap <buffer> l     <Plug>(unite_do_default_action)
endfunction
" }}}
" vimfiler {{{
let g:vimfiler_as_default_explorer  = 1
let g:vimfiler_safe_mode_by_default = 0
let g:vimfiler_ignore_pattern       = '\.o\|^\.'  " ignore object files and dotfiles
let g:vimfiler_explorer_columns     = ""
augroup vimfiler
  autocmd FileType vimfiler call s:vimfiler_my_settings()
augroup END

function! s:vimfiler_my_settings()
  " non defaults
  nmap <buffer> h  <Plug>(vimfiler_toggle_mark_current_line)
  nmap <buffer> i  <Plug>(vimfiler_loop_cursor_up)
  nmap <buffer> j  <Plug>(vimfiler_smart_h)
  nmap <buffer> k  <Plug>(vimfiler_loop_cursor_down)
  nmap <buffer> l  <Plug>(vimfiler_expand_tree)
  nmap <buffer> cc <Plug>(vimfiler_copy_file)
  nmap <buffer> dd <Plug>(vimfiler_delete_file)
  nmap <buffer> gk <Plug>(vimfiler_jump_last_child)
  nmap <buffer> gi <Plug>(vimfiler_jump_first_child)
  nmap <silent><buffer><expr> v vimfiler#do_action('vsplit')
  nmap <silent><buffer><expr> s vimfiler#do_action('split')
  nmap <silent><buffer><expr> p vimfiler#do_action('tabdrop')
  nmap <silent><buffer><expr> o vimfiler#do_action('above')
  nmap <silent><buffer><expr> b vimfiler#do_action('below')
  nmap <silent><buffer><expr> x vimfiler#do_action('ex')
  nmap <silent><buffer><expr> f vimfiler#do_action('grep')
  nmap <silent><buffer><expr> t vimfiler#do_action('tabopen')
  nmap <silent><buffer><expr> u vimfiler#do_action('rec/async')
  nnoremap <buffer> <C-b> <C-^>zvzz

  " defaults
  nmap <buffer> gg		    <Plug>(vimfiler_cursor_top)
  nmap <buffer> <C-l>			<Plug>(vimfiler_redraw_screen)
  nmap <buffer> <S-Space>	<Plug>(vimfiler_toggle_mark_current_line_up)
  nmap <buffer> *         <Plug>(vimfiler_toggle_mark_all_lines)
  nmap <buffer> &         <Plug>(vimfiler_mark_similar_lines)
  nmap <buffer> U         <Plug>(vimfiler_clear_mark_all_lines)
  nmap <buffer> m         <Plug>(vimfiler_move_file)
  nmap <buffer> Cc        <Plug>(vimfiler_clipboard_copy_file)
  nmap <buffer> Cm        <Plug>(vimfiler_clipboard_move_file)
  nmap <buffer> Cp        <Plug>(vimfiler_clipboard_paste)
  nmap <buffer> r         <Plug>(vimfiler_rename_file)
  nmap <buffer> K         <Plug>(vimfiler_make_directory)
  nmap <buffer> N         <Plug>(vimfiler_new_file)
  nmap <buffer> e     		<Plug>(vimfiler_execute)
  nmap <buffer> L         <Plug>(vimfiler_switch_to_drive)
  nmap <buffer> ~         <Plug>(vimfiler_switch_to_home_directory)
  nmap <buffer> \         <Plug>(vimfiler_switch_to_root_directory)
  nmap <buffer> <C-j>			<Plug>(vimfiler_switch_to_history_directory)
  nmap <buffer> <BS>		  <Plug>(vimfiler_switch_to_parent_directory)
  nmap <buffer> .         <Plug>(vimfiler_toggle_visible_ignore_files)
  nmap <buffer> H         <Plug>(vimfiler_popup_shell)
  nmap <buffer> <Enter>   <Plug>(vimfiler_edit_file)
  nmap <buffer> E         <Plug>(vimfiler_split_edit_file)
  nmap <buffer> B         <Plug>(vimfiler_edit_binary_file)
  nmap <buffer> ge        <Plug>(vimfiler_execute_external_filer)
  nmap <buffer> !         <Plug>(vimfiler_execute_shell_command)
  nmap <buffer> q         <Plug>(vimfiler_hide)
  nmap <buffer> Q         <Plug>(vimfiler_exit)
  nmap <buffer> -         <Plug>(vimfiler_close)
  nmap <buffer> ?         <Plug>(vimfiler_help)
  nmap <buffer> O         <Plug>(vimfiler_open_file_in_another_vimfiler)
  nmap <buffer> <C-g>			<Plug>(vimfiler_print_filename)
  nmap <buffer> g<C-g>		<Plug>(vimfiler_toggle_maximize_window)
  nmap <buffer> yy        <Plug>(vimfiler_yank_full_path)
  nmap <buffer> M         <Plug>(vimfiler_set_current_mask)
  nmap <buffer> gr        <Plug>(vimfiler_grep)
  nmap <buffer> gf        <Plug>(vimfiler_find)
  nmap <buffer> S         <Plug>(vimfiler_select_sort_type)
  nmap <buffer> <C-v>     <Plug>(vimfiler_switch_vim_buffer_mode)
  nmap <buffer> gc        <Plug>(vimfiler_cd_vim_current_dir)
  nmap <buffer> gs        <Plug>(vimfiler_toggle_safe_mode)
  nmap <buffer> gS        <Plug>(vimfiler_toggle_simple_mode)
  nmap <buffer> a         <Plug>(vimfiler_choose_action)
  nmap <buffer> Y         <Plug>(vimfiler_pushd)
  nmap <buffer> P         <Plug>(vimfiler_popd)
  nmap <buffer> T         <Plug>(vimfiler_expand_tree_recursive)
  nmap <buffer> I         <Plug>(vimfiler_cd_input_directory)
endfunction
" }}}
" }}}
" General {{{
" Set options {{{
set ttyfast                    " redraw screen faster
set restorescreen=on           " restore screen contents on exit
set clipboard=unnamedplus      " by default, use system clipboard for yanks ('+' register)
set titlestring=%t\            " file name
set title titlelen=150         " max length of title string
set number                     " show line numbers
set relativenumber             " use relative line numbers
set backspace=indent,eol,start " allow backspace in insert mode
set esckeys                    " make numpad work
set autoread                   " reload files changed outside of vim
set splitbelow                 " splits open below
set splitright                 " vsplits open on right
set hidden                     " allows navigating away from buffers with unsaved changes
set fillchars=""               " no dashes in folds or vertical bars in vsplits
set noruler                    " don't show the ruler
set laststatus=2               " always display the statusline
set history=1000               " length of command history
set showmode                   " show what mode we're in on the bottom line
set showcmd                    " show current command or visual selection info in bottom line
set showmatch                  " flash to matching paren when typing
set matchtime=3                " tenths of a second to flash to matching paren
set nocursorline               " don't hilight cursor line
set incsearch                  " find as you type
set hlsearch                   " hilight search terms
set magic                      " change how backslashes are handled in searches
set ignorecase                 " case insensitive search by default
set smartcase                  " case sensitive search if search contains uppercase letter
set nostartofline              " don't reset cursor to start of line when moving around
set nrformats=hex              " for C-a and C-x. recognize '0x' prefix as hex
set scrolljump=1               " lines to scroll when cursor leaves screen
set scrolloff=1                " start scrolling when 8 lines away from margins
set updatetime=50              " make CursorHold autocommand and swap writes happen more frequently
set encoding=utf8              " new files use utf-8 encoding by default
set ffs=unix,dos,mac           " new files use unix line endings by default
set timeoutlen=2000            " wait for 1 second to time out leader
set cryptmethod=blowfish       " more secure encryption for vim -x
set switchbuf=usetab           " look to see if buffer is already open in another window or tab
set formatoptions-=r           " don't continue comment when hitting enter in insert mode
set formatoptions-=o           " don't automatically continue comment when hitting o in normal mode
set guioptions-=m              " hide gui menu bar
set guioptions-=T              " hide gui toolbar
set guioptions-=r              " hide gui righthand scrollbar
set guioptions-=e              " use regular tabline
set guioptions-=L              " no left scrollbar
set virtualedit=block          " allow visual block mode to move to where there aren't actually characters
set noswapfile                 " seriously who needs them
set tags=./.tags;              " search for .tags file upward (:h file-searching)
set previewheight=20
set listchars=tab:▸\ ,trail:·,extends:>,eol:¶
set dictionary=/usr/share/dict/words  " dictionary completion with <C-X><C-K>
set suffixesadd+=.py,.rb       " suffixes to attempt to use for gf command
set shell=bash
syntax on                      " syntax hilighting
syntax sync minlines=256       " speed up syntax hilighting
augroup SyntaxSync
  autocmd BufReadPost syntax sync fromstart
augroup END
let g:no_ocaml_maps = 1
" }}}
" Completion options {{{
set completeopt=longest,menuone
" hitting enter when completion menu is visible selects item
inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
" }}}
" Fold {{{
" zf#j manually folds # lines, or zf in visual mode selection.
set foldnestmax =1   " folds only one level deep
set foldmethod  =manual
augroup SyntaxFold
  autocmd BufWinEnter    *.java           set foldnestmax=2 foldlevel=1
  autocmd BufWinEnter    *.c,*.cpp,*.java set foldmethod=syntax " define syntax folds when file loads
  autocmd InsertEnter    *.c,*.cpp,*.java set foldmethod=manual " once we start typing, using manual folds
augroup END
" ctrl+spacebar toggles folds in normal mode, doesn't work in gvim
nnoremap <silent> <C-@> @=(foldlevel('.')?'za':"\<Space>")<CR>
" }}}
" Tab/Indent {{{
set autoindent      " auto indent line to match above line when hitting enter
"set cindent        " newer and better smartindent
set smarttab        " make tabs more consistent with softtabstop
set shiftwidth  =2  " amount of whitespace to insert or remove using normal mode indentation commands
set softtabstop =2  " amount of whitespace deleted by backspace
set tabstop     =2  " width of tab character
set shiftround      " indent by multiples of shiftwidth
set expandtab       " use spaces instead of tabs
set linebreak       " wrap lines at nice points
set textwidth=0     " disables textwidth
filetype plugin on
filetype indent on

" Set tabstop, softtabstop and shiftwidth to the same value
command! -nargs=* Stab call Stab()
function! Stab()
  let l:tabstop = 1 * input('set tabstop = softtabstop = shiftwidth = ')
  if l:tabstop > 0
    let &l:sts = l:tabstop
    let &l:ts = l:tabstop
    let &l:sw = l:tabstop
  endif
  echomsg
  call SummarizeTabs()
endfunction
cnoreabbrev stab Stab

function! SummarizeTabs()
  try
    echohl ModeMsg
    echon 'tabstop='.&l:ts
    echon ' shiftwidth='.&l:sw
    echon ' softtabstop='.&l:sts
    if &l:et
      echon ' expandtab'
    else
      echon ' noexpandtab'
    endif
  finally
    echohl None
  endtry
endfunction
" }}}
" Wildmenu {{{
if has("wildmenu")
  set wildmenu                    " turn on wildmenu
  set wildignorecase              " wildmenu doesn't care about case
  set wildmode=longest:full,full
  set wildignore=*.o,*.a,*~,*.pyc " ignore compiled files
  set wildignore+=*.bmp,*.gif,*.ico,*.jpg,*.jpeg,*.mp4,*.mkv,*.avi,*.pdf,*.png,*.mp3
  set wildignore+=*.m4v,*.flv,*.flac,*.wma,*.doc,*.docx,*.ppt,*.pptx,*.m4a,*.m2ts,*.m3u
  set wildignore+=*:2\\,S,*:2\\,RS,*:2\\,FS,*:2\\,,*:2\\,FRS " for mutt
  set wildignore+=.DS_Store,.git,.hg,.svn
  set wildignore+=*~,*.swp,*.tmp
endif
" }}}
" }}}
" Keymaps {{{
" Misc {{{
function! Altmap(char) " map a character to Alt key in both vim and gvim
  if has('gui_running') | return '<A-'.a:char.'>' | else | return '<Esc>'.a:char|endif
endfunction
let cspace = has("gui_running") ? "<C-Space>" : "<C-@>"
" exec 'nnoremap ' . cspace . 'a :somecommand'

let mapleader = ','  " use comma instead of \ as leader
inoremap <C-c> <Esc><Esc>
nnoremap <Esc>[Z v%
onoremap <C-f> /\V

" increment numbers in visual mode, only search within selection
vnoremap <C-a> :call Increment()<CR>
xnoremap <C-f> <Esc>/\%V

" diffget/diffobtain
nnoremap dg do

" line yanks
nnoremap Y y$
nnoremap yl :let c=col(".")<CR>^v$hy:call cursor(line("."),c)<CR>

" c/C/x/X operators go to black hole instead of unnamedplus register specified by clipboard setting
nnoremap <expr> c v:register == '+' ? '"_c' : 'c'
nnoremap "+c "+c
nnoremap <expr> C v:register == '+' ? '"_C' : 'C'
nnoremap "+C "+C
nnoremap <expr> x v:register == '+' ? '"_x' : 'x'
nnoremap "+x "+x
nnoremap <expr> X v:register == '+' ? '"_X' : 'X'
nnoremap "+X "+X

" searching jumps to middle of screen, and opens fold if in one
nnoremap ? :set cursorline cursorcolumn<CR>?
nnoremap n :set cursorline cursorcolumn<CR>nzv
nnoremap N :set cursorline cursorcolumn<CR>Nzv
nmap     / <Plug>SneakPrevious
cnoremap <silent> <C-c> <C-c>:set nocursorline nocursorcolumn<CR>

" always show multiple tag options, open in new window
"nnoremap <C-]> <C-w>g<C-]>
nnoremap <C-]> g<C-]>

" shifting doesn't exit visual mode
vnoremap < <gv
vnoremap > >gv

" up/down arrow keys go up and down by visual lines
inoremap <up>   <C-O>gk
inoremap <down> <C-O>gj
nnoremap <up>        gk
nnoremap <down>      gj
vnoremap <up>        gk
vnoremap <down>      gj

" left/right arrow keys indent
nnoremap <Left>      <<
nnoremap <Right>     >>
" }}}
" next/former objects {{{
omap h i
onoremap in( :<c-u>normal! f(vi(<CR>
onoremap in[ :<c-u>normal! f[vi[<CR>
onoremap in{ :<c-u>normal! f{vi{<CR>
onoremap in< :<c-u>normal! f<vi<<CR>
onoremap in" :<c-u>normal! f"vi"<CR>
onoremap in' :<c-u>normal! f'vi'<CR>
onoremap in` :<c-u>normal! f`vi`<CR>

onoremap if( :<c-u>normal! F)vi(<CR>
onoremap if[ :<c-u>normal! F]vi[<CR>
onoremap if{ :<c-u>normal! F}vi{<CR>
onoremap if< :<c-u>normal! F>vi<<CR>
onoremap if" :<c-u>normal! F"vi"<CR>
onoremap if' :<c-u>normal! F'vi'<CR>
onoremap if` :<c-u>normal! F`vi`<CR>

onoremap an( :<c-u>normal! f(va(<CR>
onoremap an[ :<c-u>normal! f[va[<CR>
onoremap an{ :<c-u>normal! f{va{<CR>
onoremap an< :<c-u>normal! f<va<<CR>
onoremap an" :<c-u>normal! f"va"<CR>
onoremap an' :<c-u>normal! f'va'<CR>
onoremap an` :<c-u>normal! f`va`<CR>

onoremap af( :<c-u>normal! F)va(<CR>
onoremap af[ :<c-u>normal! F]va[<CR>
onoremap af{ :<c-u>normal! F}va{<CR>
onoremap af< :<c-u>normal! F>va<<CR>
onoremap af" :<c-u>normal! F"va"<CR>
onoremap af' :<c-u>normal! F'va'<CR>
onoremap af` :<c-u>normal! F`va`<CR>

" easier to reach versions of above next/former maps
omap inp in(
omap inb in[
omap inc in{
omap ind in"
omap ins in'

omap ifp if(
omap ifb if[
omap ifc if{
omap ifd if"
omap ifs if'

omap anp an(
omap anb an[
omap anc an{
omap and an"
omap ans an'

omap afp af(
omap afb af[
omap afc af{
omap afd af"
omap afs af'

" easier to reach maps for built in text objects
onoremap ip i(
onoremap ib i[
onoremap ic i{
onoremap id i"
onoremap is i'

onoremap ap a(
onoremap ab a[
onoremap ac a{
onoremap ad a"
onoremap as a'
" }}}
" ijkl instead of hjkl {{{
nnoremap j h
vnoremap j h
nnoremap <expr> i (v:count > 5 ? "m'" . v:count . 'k' : (v:count == 0 ? 'gk' : 'k'))
vnoremap i k
nnoremap <expr> k (v:count > 5 ? "m'" . v:count . 'j' : (v:count == 0 ? 'gj' : 'j'))
vnoremap k j

" since 'i' is now used for motion, make 'h' do what 'i' used to
nnoremap h i
nnoremap H I
vnoremap h i
vnoremap H I
nnoremap I H

" motions by display line, insert at last insert mode position
nnoremap gh gi
nnoremap gk gj
nnoremap gi gk

" move by folds
nnoremap zj zi
nnoremap zk zj
nnoremap zi zk
" }}}
" function keys {{{
nnoremap <F1>       :call StripTrailingWhitespace()<CR>
nnoremap <F2>       :set spell!<CR>
nnoremap <F12>      :GundoToggle<CR>
" }}}
" defualt (comma) leader maps {{{
nnoremap <silent> <leader>a    :redraw!<CR>
nnoremap <silent> <leader>bb   :Bufsearch<Space>
nnoremap <silent> <leader>ba   :Allsearch<Space>
"        <silent> <leader>c    nerdcommenter maps
vnoremap <silent> <leader>dg   :diffget <Bar> diffupdate<CR>
vnoremap <silent> <leader>do   :diffget <Bar> diffupdate<CR>
vnoremap <silent> <leader>dp   :diffput <Bar> diffupdate<CR>
nnoremap <silent> <leader>du   :diffupdate<CR>
nnoremap <silent> <leader>e    :QuickRun -mode n<CR>
vnoremap <silent> <leader>e    :QuickRun -mode v<CR>
nnoremap <silent> <leader>f    :set foldmethod=syntax<CR>:set foldmethod=manual<CR>
"                         g    fugitive and signify maps
nnoremap <silent> <leader>l    :ls<CR>:b
"                         m    make maps
nnoremap <silent> <leader>p    :set list!<CR>
nnoremap <silent> <leader>q    :q <Bar> redraw!<CR>
nnoremap <silent> <leader>r    :Dispatch!<CR>
nnoremap <silent> <leader>s    :syntax sync fromstart<CR>
vnoremap <silent> <leader>s    :!sort -f<CR>
nnoremap <silent> <leader>ta   :Alltodo<CR>
nnoremap <silent> <leader>tl   :call ToggleLocationList()<CR>
nnoremap <silent> <leader>tq   :let g:toggle_list_copen_command="copen"<CR>
                              \:call ToggleQuickfixList()<CR>
nnoremap <silent> <leader>tQ   :let g:toggle_list_copen_command="Copen"<CR>
                              \:call ToggleQuickfixList()<CR>
nnoremap <silent> <leader>tt   :Buftodo<CR>
nnoremap <silent> <leader>u    yyp^v$r
"                         v    search/replace maps
nnoremap <silent> <leader>w    :w!<CR>
nnoremap <silent> <leader>x    :wq<CR>
nnoremap <silent> <leader>zh   :echo map(synstack(line('.'),col('.')),'synIDattr(v:val,"name")')<CR>
nnoremap <silent> <leader>zv   :tabedit $MYVIMRC<CR>
nnoremap <silent> <leader><CR> :set nocursorline nocursorcolumn<CR>:nohlsearch<CR>

nnoremap <silent> <leader><leader>r  :Dispatch<CR>

" search/replace maps
nnoremap <leader>v          :s/\v
vnoremap <leader>v          :s/\v
nnoremap <leader>V          :s/\V
vnoremap <leader>V          :s/\V
nnoremap <leader><leader>v  :%s/\v
nnoremap <leader><leader>V  :%s/\V

" <leader>g[ikht] taken by signify
nnoremap <silent> <leader>gb  :Gblame<CR>
nnoremap <silent> <leader>gc  :Gcommit --verbose<CR>
nnoremap <silent> <leader>gd  :Gdiff<CR>
nnoremap <silent> <leader>ge  :Gedit<CR>
nnoremap <silent> <leader>gf  :silent Glog <Bar> redraw!<CR>
nnoremap <silent> <leader>gg  :SignifyToggle<CR>
nnoremap <silent> <leader>gla :silent Glog -- <Bar> redraw!<CR>
nnoremap <silent> <leader>glf :silent Glog -- % <Bar> redraw!<CR>
nnoremap <silent> <leader>gp  :call GitPush()<CR>
nnoremap <silent> <leader>gr  :Gread<CR>
nnoremap <silent> <leader>gs  :Gstatus<CR>
nnoremap <silent> <leader>gw  :Gwrite<CR>

" Make
nnoremap <leader>ma          :Make! -j4<CR>
nnoremap <leader><leader>ma  :Make  -j4<CR>
nnoremap <leader>mc          :Make! clean<CR>
nnoremap <leader><leader>mc  :Make  clean<CR>
nnoremap <leader>mf          :Make! -j4 <C-r>=expand('%:r')<CR><CR>
nnoremap <leader><leader>mf  :Make  -j4 <C-r>=expand('%:r')<CR><CR>

" Under cursor or visual selection, search Buffer or Arglist
nnoremap <leader>* :<C-U>call VimGrep(substitute(escape(expand("<cword>")
                      \, '\'), '\n', '\\n', 'g'), "%", " <BAR> cw")<CR>
vnoremap <leader>* :<C-U>call VimGrep(substitute(escape(@*, '\/.*$^~[]')
                      \, "\n", '\\n', "g"), "%", " <BAR> cw")<CR>
nnoremap <leader># :<C-U>call VimGrep(substitute(escape(expand("<cword>")
                      \, '\'), '\n', '\\n', 'g'), "##", " <BAR> cw")<CR>
vnoremap <leader># :<C-U>call VimGrep(substitute(escape(@*, '\/.*$^~[]')
                      \, "\n", '\\n', "g"), "##", " <BAR> cw")<CR>
" }}}
" space leader maps. unite + tabularize {{{
nnoremap <Space>a   :<C-u>Unite -start-insert -buffer-name=file_rec   file_rec/async<CR>
nnoremap <Space>b   :<C-u>Unite -start-insert -buffer-name=buffers    buffer<CR>
nnoremap <Space>c   :<C-u>Unite -start-insert -buffer-name=registers  register<CR>
nnoremap <Space>d   :<C-u>Unite -start-insert -buffer-name=tabs       tab:no-current<CR>
nnoremap <Space>f   :<C-u>Unite -start-insert -buffer-name=files      file<CR>
nnoremap <Space>g   :<C-u>Unite -start-insert -buffer-name=grep       grep:.<CR>
nnoremap <Space>h   :<C-u>Unite -start-insert -buffer-name=help       help<CR><CR>
nnoremap <Space>i   <C-w><Up>
nnoremap <Space>j   <C-w><Left>
nnoremap <Space>k   <C-w><Down>
nnoremap <Space>l   <C-w><Right>
nnoremap <Space>n   :<C-u>Unite -start-insert -buffer-name=lines      line<CR>
nnoremap <Space>o   :<C-u>Unite -start-insert -buffer-name=outline    outline<CR>
nnoremap <Space>pl  :<C-u>Unite -no-start-insert neobundle/log<CR>
nnoremap <Space>pu  :<C-u>Unite -no-start-insert neobundle/update<CR>
nnoremap <Space>r   :<C-u>Unite -start-insert -buffer-name=recent     file_mru<CR>
nnoremap <Space>s   :<C-u>UniteWithInput      -buffer-name=locate     locate<CR>
nnoremap <Space>t   :<C-u>Unite -start-insert -buffer-name=tags       tag<CR>a<BS>
nnoremap <Space>w   :<C-u>Unite -start-insert -buffer-name=window     window:no-current<CR>
nnoremap <Space>y   :<C-u>Unite -start-insert -buffer-name=yanks      history/yank<CR>
nnoremap <Space>'   :<C-u>Unite -start-insert -buffer-name=marks      mark<CR>

" Tabularize
nnoremap <Space>=       :Tabularize /=<CR>
vnoremap <Space>=       :Tabularize /=<CR>
nnoremap <Space>:       :Tabularize /:\zs<CR>
vnoremap <Space>:       :Tabularize /:\zs<CR>
nnoremap <Space><Bar>   :Tabularize /<Bar><CR>
vnoremap <Space><Bar>   :Tabularize /<Bar><CR>
nnoremap <Space>-       :Tabularize /-<CR>
vnoremap <Space>-       :Tabularize /-<CR>
" }}}
" ctrl normal mode {{{
nnoremap <C-w><C-b> :VimFilerExplorer -find<CR>:redraw!<CR>
nnoremap <C-b>      :VimFiler -find<CR>:redraw!<CR>
nnoremap <C-f>      :set cursorline cursorcolumn<CR>/\V
nnoremap <C-h>      :TagbarOpen fjc<CR>
nnoremap <C-n>      gt
nnoremap <C-p>      gT
nnoremap <C-w>o     <C-w>o:redraw!<CR>
nnoremap <C-w>s     <C-w>s:redraw!<CR>
nnoremap <C-w>v     <C-w>v:redraw!<CR>
" }}}
" ctrl insert mode {{{
inoremap <C-a>      <Home>
inoremap <C-e>      <End>
" }}}
" alt normal mode {{{
exec 'nnoremap <silent> ' . Altmap('a') . ' :AirlineToggle<CR>'
exec 'nnoremap <silent> ' . Altmap('h') . ' :set nocursorline nocursorcolumn<CR>:nohlsearch<CR>'
exec 'nnoremap <silent> ' . Altmap('i') . ' :resize +2<CR>'
exec 'nnoremap <silent> ' . Altmap('j') . ' :vertical resize -2<CR>'
exec 'nnoremap <silent> ' . Altmap('k') . ' :resize -2<CR>'
exec 'nnoremap <silent> ' . Altmap('l') . ' :vertical resize +2<CR>'
exec 'nnoremap <silent> ' . Altmap('m') . ' :match none<CR>'
exec 'nnoremap <silent> ' . Altmap('n') . ' :tabmove +1<CR>'
exec 'nnoremap <silent> ' . Altmap('p') . ' :tabmove -1<CR>'
exec 'nnoremap <silent> ' . Altmap('q') . ' :quitall<CR>'
exec 'nnoremap <silent> ' . Altmap('1') . ' 1gt'
exec 'nnoremap <silent> ' . Altmap('2') . ' 2gt'
exec 'nnoremap <silent> ' . Altmap('3') . ' 3gt'
exec 'nnoremap <silent> ' . Altmap('4') . ' 4gt'
exec 'nnoremap <silent> ' . Altmap('5') . ' 5gt'
exec 'nnoremap <silent> ' . Altmap('6') . ' 6gt'
exec 'nnoremap <silent> ' . Altmap('7') . ' 7gt'
exec 'nnoremap <silent> ' . Altmap('8') . ' 8gt'
exec 'nnoremap <silent> ' . Altmap('9') . ' 9gt'
exec 'nnoremap <silent> ' . Altmap('0') . ' :tablast<CR>'
" }}}
" alt insert mode {{{
exec 'inoremap ' . Altmap('i') . '   <Up>'
exec 'inoremap ' . Altmap('j') . '   <Left>'
exec 'inoremap ' . Altmap('k') . '   <Down>'
exec 'inoremap ' . Altmap('l') . '   <Right>'
exec 'inoremap ' . Altmap('b') . '   <S-Left>'
exec 'inoremap ' . Altmap('B') . '   <C-Left>'
exec 'inoremap ' . Altmap('w') . '   <S-Right>'
exec 'inoremap ' . Altmap('W') . '   <C-Right>'
" }}}
" slash leader maps. tmuxify {{{
function! TmuxifySendLines(count, direction)
  let l = line(".")
  let c = col(".")

  if a:count == 0
    execute 'normal! "vyy'
  else
    execute 'normal! "vy' . a:count . a:direction
  endif

  TxSend(@v)
  call cursor(l, c)
endfunction

nnoremap <silent> \a  :call tmuxify#pane_send_raw('C-u')<CR>:TxSend('clear')<CR>
nnoremap <silent> \b  :TxSend(GenerateBuildCommand())<CR>
nnoremap <silent> \c  :TxSigInt<CR>
nnoremap <silent> \d  :call tmuxify#pane_send_raw('C-d')<CR>
nnoremap <silent> \i  :call TmuxifySendLines(v:count, "k")<CR>
nnoremap <silent> \k  :call TmuxifySendLines(v:count, "j")<CR>
nnoremap <silent> \l  :call tmuxify#pane_send_raw('C-l')<CR>
"                 \m  make mappings
nnoremap <silent> \o  :TxCreate<CR>
nnoremap <silent> \q  :TxKill<CR>
nnoremap <silent> \r  :TxRun<CR>
nnoremap <silent> \s  "vyy:TxSend(@v)<CR>
vnoremap <silent> \s  "vy:TxSend(@v)<CR>
nnoremap <silent> \ts :TxSetPane<CR>
nnoremap <silent> \td :TxSetPane<CR>0<CR>1<CR>1<CR>:echo 'attached to 0:0:1'<CR>
nnoremap <silent> \\  :TxSend<CR>

nnoremap <silent> \<CR> :call tmuxify#pane_send_raw('C-m')<CR>

nnoremap <silent> \ma :TxSend('make')<CR>
nnoremap <silent> \mc :TxSend('make clean')<CR>
nnoremap <silent> \mf :TxSend(GenerateBuildCommand())<CR>
" }}}
" }}}
" vim: foldmethod=marker foldlevel=1 textwidth=0
