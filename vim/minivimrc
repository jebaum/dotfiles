" Initial setup {{{
colorscheme default
runtime macros/matchit.vim
let mapleader = ','
augroup LineNumberAutoToggle
  autocmd InsertEnter * set norelativenumber
  autocmd InsertLeave * set relativenumber
augroup END

call plug#begin('~/.vim/bundle')
Plug 'morhetz/gruvbox'
if has('python') || has('python3') " pip3 install neovim only sets 'python3' to 1
  Plug 'honza/vim-snippets'
  Plug 'SirVer/ultisnips'
endif
if has('nvim')
  set shortmess+=c " helps with completion flicker
  Plug 'Shougo/deoplete.nvim'
else
  Plug 'othree/vim-autocomplpop'
  Plug 'eparreno/vim-l9'
  Plug 'scrooloose/syntastic'
endif
Plug 'bruno-/vim-husk'
Plug 'dahu/vimple'
Plug 'inside/vim-search-pulse'
Plug 'junegunn/fzf'
Plug 'junegunn/fzf.vim'
Plug 'junegunn/vim-easy-align'
Plug 'junegunn/vim-oblique'
Plug 'junegunn/vim-pseudocl'
Plug 'justinmk/vim-sneak'
Plug 'tommcdo/vim-exchange', {'on': ['<Plug>(Exchange)', '<Plug>(ExchangeClear)', '<Plug>(ExchangeLine)']}
Plug 'tpope/vim-jdaddy'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-unimpaired'
Plug 'wellle/targets.vim'
call plug#end()

let g:gruvbox_invert_selection=0
let g:gruvbox_contrast_dark='medium'
set background=dark
colorscheme gruvbox
" override some defaults
function! TweakColors()
  " current match when hitting n/N to navigate
  highlight ObliqueCurrentMatch     ctermfg=16  ctermbg=40 guifg=#000000 guibg=#00D700
  " current match when actively searching
  highlight ObliqueCurrentIncSearch ctermfg=16  ctermbg=40  guifg=#000000 guibg=#00D700
  " color of search text in command line
  highlight ObliqueLine             ctermfg=229 guifg=#FFFFAF
  " color of matches the cursor isn't on when actively searching
  highlight IncSearch               ctermfg=250 ctermbg=24  guifg=#BCBCBC guibg=#005F87
  " color of matches the cursor isn't on after finished searching
  highlight Search                  ctermfg=255 ctermbg=24  guifg=#EEEEEE guibg=#005F87

  highlight Folded     ctermbg=16                               guibg=#000000
  highlight Function   ctermfg=43                guifg=#00D7AF
  highlight MatchParen ctermfg=16   ctermbg=201  guifg=#000000  guibg=#FF00FF
  highlight Normal     ctermfg=223               guifg=#FFD7AF  guibg=#202020
  highlight SpecialKey ctermfg=231  ctermbg=236  guifg=#FFFFFF  guibg=#303030
  highlight String     ctermfg=46                guifg=#33D933

  " copied from statline.vim
  highlight User1 ctermfg=221  ctermbg=232  cterm=none guifg=#FFD75F  guibg=#080808  gui=none
  highlight User2 ctermfg=47   ctermbg=232  cterm=none guifg=#00FF5F  guibg=#080808  gui=none
  highlight User3 ctermfg=196  ctermbg=232  cterm=bold guifg=#FF0000  guibg=#080808  gui=bold
  highlight User4 ctermfg=49   ctermbg=232  cterm=none guifg=#00FFAF  guibg=#080808  gui=none
  highlight User5 ctermfg=47   ctermbg=232  cterm=none guifg=#00FF5F  guibg=#080808  gui=none
  highlight User6 ctermfg=231  ctermbg=232  cterm=none guifg=#FFFFFF  guibg=#080808  gui=none
  highlight User7 ctermfg=253  ctermbg=232  cterm=none guifg=#DADADA  guibg=#080808  gui=none
  highlight User8 ctermfg=207  ctermbg=232  cterm=none guifg=#FF5FFF  guibg=#080808  gui=none
  highlight User9 ctermfg=208  ctermbg=232  cterm=none guifg=#FF8700  guibg=#080808  gui=none

  let g:vim_search_pulse_color_list = has('gui_running') || (has('nvim') && &termguicolors) ?
        \ ['#3a3a3a', '#444444', '#4e4e4e', '#585858', '#606060'] :
        \ [238, 239, 240, 241, 242, 243, 244, 245, 246]
endfunction
call TweakColors()
augroup TweakColors
  autocmd!
  autocmd Syntax * call TweakColors()
augroup END
" }}}

" generate map for alt and <C-Space> in both vim and gvim {{{
function! Altmap(char)
  if has('gui_running') || has('nvim') | return '<A-'.a:char.'>' | else | return '<Esc>'.a:char|endif
endfunction
function! AltShiftmap(char)
  if has('gui_running') || has('nvim') | return '<A-S-'.a:char.'>' | else | return '<Esc>'.a:char|endif
endfunction
let g:ctrl_space = has("gui_running") ? "<C-Space>" : "<C-@>"
" }}}

" deoplete {{{
let g:deoplete#enable_at_startup            = 1
let g:deoplete#enable_smart_case            = 1
let g:deoplete#auto_completion_start_length = 1
let g:deoplete#sources                      = {}
let g:deoplete#sources._                    = ['omni', 'buffer', 'ultisnips']
let g:deoplete#sources.text                 = ['buffer', 'dictionary']
let g:deoplete#sources.pandoc               = ['buffer', 'dictionary']
let g:deoplete#sources.javascript           = ['omni', 'buffer']
let g:deoplete#sources.java                 = ['omni', 'buffer', 'ultisnips']

" https://gregjs.com/vim/2016/configuring-the-deoplete-asynchronous-keyword-completion-plugin-with-tern-for-vim/
if !exists('g:deoplete#omni#input_patterns')
  let g:deoplete#omni#input_patterns = {}
endif
let g:deoplete#omni#input_patterns.javascript = ['[^. \t0-9]\.\w*']
    let g:deoplete#omni#input_patterns.java = [
        \'[^. \t0-9]\.\w*',
        \'[^. \t0-9]\->\w*',
        \'[^. \t0-9]\::\w*',
        \]
    let g:deoplete#omni#input_patterns.jsp = ['[^. \t0-9]\.\w*']
    let g:deoplete#ignore_sources = {}
    let g:deoplete#ignore_sources._ = ['javacomplete2']

" let g:neocomplete#force_omni_input_patterns.javascript = '[^. \t]\.\w*'

" augroup DeopletePclose " close preview window when finishing completion or leaving insert mode
    " autocmd!
    " autocmd InsertLeave,CompleteDone * if pumvisible() == 0 | pclose | endif
" augroup END

augroup DeopleteOmniFuncs
  autocmd!
  " autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
  " autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
  " autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
  autocmd FileType javascript setlocal omnifunc=tern#Complete
  " autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
  " autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
augroup end
" }}}
" easy-align {{{
xmap ga <Plug>(EasyAlign)
nmap ga <Plug>(EasyAlign)
" }}}
" exchange {{{
" need to define default mappings in vimrc for vim-plug lazy loading to work
nmap cx <Plug>(Exchange)
xmap X <Plug>(Exchange)
nmap cxc <Plug>(ExchangeClear)
nmap cxx <Plug>(ExchangeLine)
let g:easy_align_bypass_fold = 1
" }}}
" fzf {{{
let g:fzf_launcher='urxvt -e sh -c %s' " TODO change to st
" }}}
" matchparen {{{
" let g:loaded_matchparen = 1 put this in neovim remote plugin!
augroup MatchParenTimeout
    autocmd!
    autocmd BufEnter * call SetMatchParenTimeout()
augroup END
function! SetMatchParenTimeout()
    let bytes = line2byte(line('$') + 1)
    if bytes > 1000000
        let b:matchparen_timeout = 1
        let b:matchparen_insert_timeout = 1
        setlocal nocursorline nocursorcolumn " TODO conflicts with general cursorline autocmd used in all bufs
        " TODO also turn off anzu here
    endif
endfunction
" }}}
" search-pulse {{{
let g:vim_search_pulse_mode = 'pattern'
" XXX the speed with which this actually happens seems to depend on the size
" of the buffer currently displayed. also affected by if folds are closed.
" some kind of very slow redrawing being done?

" let g:vim_search_pulse_disable=0 " toggle this on huge buffers?
" TODO pulse seems to do some kind of intelligent interrupting of the drawing loop
" if you hit n again while it's still in the middle of the loop
" i should figure out how that's done and reimplement a simpler version that
" just does cursor line /column flashing, instead of arbitrary patterns
let g:vim_search_pulse_duration = 50
let g:vim_search_pulse_disable_auto_mappings = 1
let g:vim_search_pulse_color_list = has('gui_running') || (has('nvim') && &termguicolors) ?
        \ ['#3a3a3a', '#444444', '#4e4e4e', '#585858', '#606060'] :
        \ [238, 239, 240, 241, 242, 243, 244, 245, 246]
augroup Pulse
    autocmd! User PrePulse
    autocmd! User PostPulse
    autocmd  User PrePulse  set cursorcolumn
    autocmd  User PostPulse set nocursorcolumn
augroup END

" }}}
" sneak  {{{
let g:sneak#use_ic_scs = 1
let g:sneak#s_next = 0
nmap f <Plug>Sneak_f
nmap F <Plug>Sneak_F
xmap f <Plug>Sneak_f
xmap F <Plug>Sneak_F
omap f <Plug>Sneak_f
omap F <Plug>Sneak_F
nmap t <Plug>Sneak_t
nmap T <Plug>Sneak_T
xmap t <Plug>Sneak_t
xmap T <Plug>Sneak_T
omap t <Plug>Sneak_t
omap T <Plug>Sneak_T

" nnoremap <expr> ; getcharsearch().forward ? ';' : ','
" nnoremap <expr> , getcharsearch().forward ? ',' : ';'
let g:sneak#streak = 0
nmap <silent> <expr> ; sneak#state().reverse ? '<Plug>SneakPrevious' : '<Plug>SneakNext'
omap <silent> <expr> ; sneak#state().reverse ? '<Plug>SneakPrevious' : '<Plug>SneakNext'
xmap <silent> <expr> ; sneak#state().reverse ? '<Plug>SneakPrevious' : '<Plug>SneakNext'
exec 'nmap <silent> <expr> '.Altmap(';').' sneak#state().reverse ? "<Plug>SneakNext" : "<Plug>SneakPrevious"'
exec 'omap <silent> <expr> '.Altmap(';').' sneak#state().reverse ? "<Plug>SneakNext" : "<Plug>SneakPrevious"'
exec 'xmap <silent> <expr> '.Altmap(';').' sneak#state().reverse ? "<Plug>SneakNext" : "<Plug>SneakPrevious"'
" }}}
" ultisnips {{{
let g:UltiSnipsExpandTrigger       = "<C-l>"
let g:UltiSnipsJumpForwardTrigger  = "<C-l>"
let g:UltiSnipsJumpBackwardTrigger = "<C-h>"
let g:UltiSnipsListSnippets        = "<C-f>"
let g:snips_author                 = 'James Baumgarten'
" }}}
" vimple {{{
let g:vimple_init_vn = 0 " vimple has a dumb version check that breaks in neovim
" }}}

" set options {{{
set number                     " show line numbers
set relativenumber             " use relative line numbers
set showmatch                  " flash to matching paren when typing
set timeout
set timeoutlen=3000
set ttimeoutlen=100
set formatoptions-=r           " don't continue comment when hitting enter in insert mode
set formatoptions-=o           " don't automatically continue comment when hitting o in normal mode
set guioptions-=m              " hide gui menu bar
set guioptions-=T              " hide gui toolbar
set guioptions-=r              " hide gui righthand scrollbar
set guioptions-=e              " use regular tabline
set guioptions-=L              " no left scrollbar
set mouse=                     " disable mouse
set listchars=tab:▶-,trail:•,extends:>,eol:¬
set nojoinspaces        " use only one space after a period when joining lines
let $NVIM_TUI_ENABLE_CURSOR_SHAPE=1
if has('nvim')
  set termguicolors
endif
" }}}

" Keymaps {{{
" Misc {{{
nnoremap H ^
nnoremap L g_
" }}}
" fix the esc/alt mapping problem in terminal vim {{{
if !has('gui_running')
  set ttimeoutlen=10
  augroup FastEscape
    autocmd!
    autocmd InsertEnter * set timeoutlen=0 ttimeoutlen=-1
    autocmd InsertLeave * set timeoutlen=2000
  augroup END
endif
" }}}
" misc g maps {{{
nnoremap          gp    gw{gw}
nnoremap          gs    gnv
nnoremap          g;    g;zz
nnoremap          g,    g,zz
" }}}
" changed default keys M - _ K {{{
nnoremap M %
onoremap M %
vnoremap M %
" make K do the opposite of J: split lines under the cursor
nnoremap K i<CR><Esc>k$
nnoremap - 10jzz
nnoremap _ 10kzz
" }}}
" easily toggle command line window with Q {{{
nnoremap Q q:
augroup CmdWindow
  autocmd!
  autocmd CmdwinEnter * nnoremap <buffer><silent> Q :q<CR>
  autocmd CmdwinEnter * nnoremap <buffer><silent> <C-c> <Esc>
augroup END
" }}}
" visual mode increment, search, shift, gV {{{
vnoremap <C-a> :call Increment()<CR>
xnoremap <C-f> <Esc>/\%V
nnoremap gV `[v`]
" }}}
" line yanks Y yl yaa {{{
nnoremap Y y$
nnoremap yl :let c=col(".")<CR>^v$hy:call cursor(line("."),c)<CR>
nnoremap yaa :let c=col(".") <BAR> let l = line(".")<CR>ggyG:call cursor(l,c)<CR>:echo 'yanked whole file'<CR>
" }}}
" c/C/x/X operators go to own registers instead of unnamed[plus] register specified by 'clipboard' {{{
nnoremap <expr> c (v:register == '+' \|\| v:register == '*') ? '"cc' : 'c'
nnoremap "+c "+c
nnoremap "*c "*c
nnoremap <expr> C (v:register == '+' \|\| v:register == '*') ? '"cC' : 'C'
nnoremap "+C "+C
nnoremap "*C "*C
nnoremap <expr> x (v:register == '+' \|\| v:register == '*') ? '"xx' : 'x'
nnoremap "+x "+x
nnoremap "*x "*x
nnoremap <expr> X (v:register == '+' \|\| v:register == '*') ? '"xX' : 'X'
nnoremap "+X "+X
nnoremap "*X "*X
" }}}
" Text Object / targets.vim maps {{{
let g:targets_pairs       = '()b {}c []r <>g'
let g:targets_quotes      = "\"d 's `e"

function! Append(type, ...)
    call feedkeys("`]a", 'n')
endfunction

function! Insert(type, ...)
    call feedkeys("`[i", 'n')
endfunction
" }}}
" k and j add to jumplist {{{
nnoremap <expr> k (v:count > 4 ? "m'" . v:count . 'k' : (v:count == 0 ? 'gk' : 'k'))
nnoremap <expr> j (v:count > 4 ? "m'" . v:count . 'j' : (v:count == 0 ? 'gj' : 'j'))
" }}}
" defualt comma leader maps {{{
" Main {{{
nnoremap <silent> <leader>a    :set opfunc=Append<CR>g@
nnoremap <silent> <leader>p    "0p
nnoremap <silent> <leader>P    "0P
nnoremap <silent> <leader>q    :q <Bar> redraw!<CR>
nnoremap <silent> <leader>sh   :echo map(synstack(line('.'),col('.')),'synIDattr(v:val,"name")')<CR>
nnoremap <silent> <leader>u    yyp^v$r=
nnoremap <silent> <leader>w    :w!<CR>
nnoremap <silent> <leader>x    :x!<CR>
nnoremap <silent> <leader>zs   :syntax sync fromstart<CR>
" }}}
" }}}
" space leader maps. fzf + vim-plug {{{
" TODO go through various fzf.vim functions and figure out which ones to use, how to customize them
let g:fzf_command_prefix = 'FZF' " easy autocompletion, and prevent overlap with ag.vim
nnoremap <silent> <Space>b   :FZFBuffers<CR>
nnoremap          <Space>c   :FZFCommands<CR>
nnoremap <silent> <Space>f   :FZFFiles<CR>
nnoremap <silent> <Space>g   :FZFLines<CR>
nnoremap <silent> <Space>G   :FZFBLines<CR>
nnoremap          <Space>h   :FZFHelptags<CR>
nnoremap <silent> <Space>H   :FZFHistory<CR>
nnoremap          <Space>l   :FZFLocate<Space>
nnoremap <silent> <Space>m   :FZFMarks<CR>
nnoremap <silent> <Space>M   :FZFMaps<CR>
nnoremap          <Space>s   :FZFSnippets<CR>
nnoremap <silent> <Space>t   :FZFTags<CR>
nnoremap <silent> <Space>T   :FZFBTags<CR>
nnoremap <silent> <Space>v   :FZFCommits<CR>
nnoremap <silent> <Space>V   :FZFBCommits<CR>
nnoremap <silent> <Space>w   :FZFWindows<CR>
nnoremap <silent> <Space>x   :FZFAg<CR>
nnoremap          <Space>X   :FZFAg<Space>
nnoremap <silent> <Space>:   :FZFHistory:<CR>
nnoremap <silent> <Space>/   :FZFHistory/<CR>

nnoremap <Space>pi       :PlugInstall<CR>
nnoremap <Space>pu       :PlugUpdate<CR>
nnoremap <Space>pU       :PlugUpgrade<CR>
" }}}
" ctrl normal mode {{{
nnoremap <C-n>              gt
nnoremap <C-p>              gT
nnoremap <C-w>o             <C-w>o:redraw!<CR>
nnoremap <C-w>s             <C-w>s:redraw!<CR>
nnoremap <C-w>v             <C-w>v:redraw!<CR>
" }}}
" ctrl insert mode {{{
inoremap <C-a>   <Home>
inoremap <C-c>   <Esc><Esc>`^
inoremap <C-e>   <End>
inoremap <Esc>   <Esc>`^
" }}}
" alt normal mode {{{
" move windows
nnoremap          gh    <C-w>H
nnoremap          gj    <C-w>J
nnoremap          gk    <C-w>K
nnoremap          gl    <C-w>L
" }}}
" alt insert mode {{{
exec 'inoremap ' . Altmap('h') . '   <Left>'
exec 'inoremap ' . Altmap('j') . '   <Down>'
exec 'inoremap ' . Altmap('k') . '   <Up>'
exec 'inoremap ' . Altmap('l') . '   <Right>'
exec 'inoremap ' . Altmap('b') . '   <S-Left>'
exec 'inoremap ' . Altmap('B') . '   <C-Left>'
exec 'inoremap ' . Altmap('w') . '   <S-Right>'
exec 'inoremap ' . Altmap('W') . '   <C-Right>'
" }}}
" neovim terminal maps {{{
if has('nvim')
    tnoremap <Esc> <C-\><C-n>
endif
let g:terminal_scrollback_buffer_size = 100000
" }}}
" }}}
" vim: foldmethod=marker foldlevel=1 foldmarker={{{,}}}
